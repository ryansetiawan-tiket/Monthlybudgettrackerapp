import { Hono } from "npm:hono";
import { cors } from "npm:hono/cors";
import { logger } from "npm:hono/logger";
import * as kv from "./kv_store.tsx";

// ============================================
// POCKETS SYSTEM - TYPE DEFINITIONS
// ============================================

type PocketType = 'primary' | 'custom';

const POCKET_IDS = {
  DAILY: 'pocket_daily',
  COLD_MONEY: 'pocket_cold_money'
} as const;

interface Pocket {
  id: string;
  name: string;
  type: PocketType;
  description?: string;
  icon?: string;
  color?: string;
  order: number;
  createdAt: string;
  status?: 'active' | 'archived';
  archivedAt?: string;
  archivedReason?: string;
  enableWishlist?: boolean;
}

const DEFAULT_POCKETS: Pocket[] = [
  {
    id: POCKET_IDS.DAILY,
    name: 'Sehari-hari',
    type: 'primary',
    description: 'Budget untuk kebutuhan sehari-hari',
    icon: 'Wallet',
    color: 'blue',
    order: 1,
    createdAt: new Date().toISOString(),
    enableWishlist: false  // Daily pocket doesn't need wishlist simulation
  },
  {
    id: POCKET_IDS.COLD_MONEY,
    name: 'Uang Dingin',
    type: 'primary',
    description: 'Dana untuk hobi dan hiburan',
    icon: 'Sparkles',
    color: 'purple',
    order: 2,
    createdAt: new Date().toISOString(),
    enableWishlist: true  // Cold money is perfect for wishlist planning
  }
];

interface PocketBalance {
  pocketId: string;
  originalAmount: number;
  transferIn: number;
  transferOut: number;
  expenses: number;
  availableBalance: number;
  lastUpdated: string;
}

interface TransferTransaction {
  id: string;
  type: 'transfer';
  amount: number;
  fromPocketId: string;
  toPocketId: string;
  fromPocketName?: string; // Stored for history preservation (added for backward compatibility)
  toPocketName?: string;   // Stored for history preservation (added for backward compatibility)
  date: string;
  note?: string;
  createdAt: string;
}

type TransactionType = 'income' | 'expense' | 'transfer';

interface TimelineEntry {
  id: string;
  type: TransactionType;
  date: string;
  description: string;
  amount: number;
  balanceAfter: number;
  icon: string;
  color: string;
  metadata?: any;
}

// ============================================
// SMART SUGGESTIONS - TYPE DEFINITIONS
// ============================================

/**
 * Suggestion Types
 */
type SuggestionType = 
  | 'transfer'        // Suggest moving money
  | 'save'           // Suggest saving
  | 'reduce'         // Reduce spending
  | 'archive'        // Archive empty pocket
  | 'warning'        // Budget warning
  | 'info';          // Informational

/**
 * Suggestion
 */
interface Suggestion {
  id: string;
  type: SuggestionType;
  title: string;
  message: string;
  priority: 'high' | 'medium' | 'low';
  actionable: boolean;
  action?: {
    label: string;
    endpoint?: string;
    params?: any;
  };
  metadata?: any;
}

/**
 * Budget Health Status
 */
interface BudgetHealth {
  status: 'healthy' | 'warning' | 'critical';
  score: number;  // 0-100
  issues: string[];
  strengths: string[];
}

// ============================================
// ARCHIVE SYSTEM - TYPE DEFINITIONS
// ============================================

/**
 * Archive Request
 */
interface ArchiveRequest {
  pocketId: string;
  monthKey: string;
  reason?: string;
}

/**
 * Archive Result
 */
interface ArchiveResult {
  success: boolean;
  archivedPocket: Pocket;
  message: string;
}

/**
 * Archive History Entry
 */
interface ArchiveHistoryEntry {
  pocketId: string;
  pocketName: string;
  archivedAt: string;
  reason: string;
  balanceAtArchive: number;
}

// ============================================
// CARRY OVER SYSTEM - TYPE DEFINITIONS
// ============================================

/**
 * Carry Over Entry
 * Represents balance carried from previous month
 */
interface CarryOverEntry {
  id: string;
  pocketId: string;
  fromMonth: string;        // '2025-10'
  toMonth: string;          // '2025-11'
  amount: number;           // Total carried over
  
  breakdown: {
    originalBalance: number;    // Starting balance bulan lalu
    income: number;            // Total income bulan lalu
    expenses: number;          // Total expenses bulan lalu
    transferIn: number;        // Total transfer masuk bulan lalu
    transferOut: number;       // Total transfer keluar bulan lalu
    finalBalance: number;      // = amount (for verification)
  };
  
  createdAt: string;        // ISO date
  autoGenerated: boolean;   // true = auto, false = manual
}

/**
 * Carry Over Summary (for display)
 */
interface CarryOverSummary {
  monthKey: string;
  pockets: Array<{
    pocketId: string;
    pocketName: string;
    carryOverAmount: number;
    hasCarryOver: boolean;
    fromMonth: string;
  }>;
  totalCarryOver: number;
}

// ============================================
// POCKETS SYSTEM - HELPER FUNCTIONS
// ============================================

/**
 * Get or create pockets for a month
 */
async function getPockets(monthKey: string): Promise<Pocket[]> {
  let pockets = await kv.get(`pockets:${monthKey}`);
  
  if (!pockets || pockets.length === 0) {
    // Auto-create default pockets
    pockets = DEFAULT_POCKETS;
    await kv.set(`pockets:${monthKey}`, pockets);
  }
  
  return pockets;
}

/**
 * Calculate balance for a specific pocket
 * @param sharedData - Optional shared data to avoid redundant fetches
 */
async function calculatePocketBalance(
  pocketId: string,
  monthKey: string,
  sharedData?: {
    budget?: any;
    expensesData?: any[];
    additionalIncome?: any[];
    transfers?: any[];
    excludeState?: any;
  }
): Promise<PocketBalance> {
  // Get all data (use shared data if provided)
  const budget = sharedData?.budget || await kv.get(`budget:${monthKey}`) || { initialBudget: 0, carryover: 0 };
  const expensesData = sharedData?.expensesData || await kv.getByPrefix(`expense:${monthKey}:`) || [];
  const additionalIncome = sharedData?.additionalIncome || await kv.getByPrefix(`income:${monthKey}:`) || [];
  const transfers = sharedData?.transfers || await kv.getByPrefix(`transfer:${monthKey}:`) || [];
  const excludeState = sharedData?.excludeState || await kv.get(`exclude-state:${monthKey}`) || { excludedExpenseIds: [], excludedIncomeIds: [] };
  
  const excludedExpenseIds = new Set(excludeState.excludedExpenseIds || []);
  const excludedIncomeIds = new Set(excludeState.excludedIncomeIds || []);
  
  let originalAmount = 0;
  let transferIn = 0;
  let transferOut = 0;
  let expensesTotal = 0;
  
  // Calculate original amount for this month
  if (pocketId === POCKET_IDS.DAILY) {
    // For DAILY pocket, use manual budget.carryover field (not auto-generated carry over)
    originalAmount = (budget.initialBudget || 0) + (budget.carryover || 0);
  } else if (pocketId === POCKET_IDS.COLD_MONEY) {
    originalAmount = additionalIncome
      .filter((income: any) => !excludedIncomeIds.has(income.id))
      .reduce((sum: number, income: any) => sum + income.amountIDR - income.deduction, 0);
  } else {
    // For custom pockets, use auto-generated carry over from previous month
    const carryOvers = await getCarryOvers(monthKey);
    const carryOver = carryOvers.find((co: CarryOverEntry) => co.pocketId === pocketId);
    
    if (carryOver) {
      originalAmount = carryOver.amount;
    }
  }
  
  // Calculate transfers
  transferIn = transfers
    .filter((t: TransferTransaction) => t.toPocketId === pocketId)
    .reduce((sum: number, t: TransferTransaction) => sum + t.amount, 0);
    
  transferOut = transfers
    .filter((t: TransferTransaction) => t.fromPocketId === pocketId)
    .reduce((sum: number, t: TransferTransaction) => sum + t.amount, 0);
  
  // Calculate expenses for this pocket
  expensesTotal = expensesData
    .filter((e: any) => e.pocketId === pocketId && !excludedExpenseIds.has(e.id))
    .reduce((sum: number, e: any) => sum + e.amount, 0);
  
  const availableBalance = originalAmount + transferIn - transferOut - expensesTotal;
  
  return {
    pocketId,
    originalAmount,
    transferIn,
    transferOut,
    expenses: expensesTotal,
    availableBalance,
    lastUpdated: new Date().toISOString()
  };
}

// ============================================
// CARRY OVER SYSTEM - HELPER FUNCTIONS
// ============================================

/**
 * Get previous month key
 */
function getPreviousMonth(monthKey: string): string {
  const [year, month] = monthKey.split('-').map(Number);
  if (month === 1) {
    return `${year - 1}-12`;
  }
  return `${year}-${String(month - 1).padStart(2, '0')}`;
}

/**
 * Format month for display
 */
function formatMonth(monthKey: string): string {
  const [year, month] = monthKey.split('-');
  const months = ['Januari', 'Februari', 'Maret', 'April', 'Mei', 'Juni', 'Juli', 'Agustus', 'September', 'Oktober', 'November', 'Desember'];
  return `${months[parseInt(month) - 1]} ${year}`;
}

/**
 * Generate carry overs for new month
 * Called when user first accesses a new month
 */
async function generateCarryOvers(
  fromMonth: string,
  toMonth: string
): Promise<CarryOverEntry[]> {
  // Get all pockets from previous month
  const pockets = await getPockets(fromMonth);
  const carryOvers: CarryOverEntry[] = [];
  
  for (const pocket of pockets) {
    // Calculate final balance of previous month
    const balance = await calculatePocketBalance(pocket.id, fromMonth);
    
    // Create carry over even if balance is 0 or negative (for tracking)
    const carryOver: CarryOverEntry = {
      id: `carryover_${toMonth}_${pocket.id}`,
      pocketId: pocket.id,
      fromMonth,
      toMonth,
      amount: balance.availableBalance,
      breakdown: {
        originalBalance: balance.originalAmount,
        income: 0, // Will be detailed in timeline
        expenses: balance.expenses,
        transferIn: balance.transferIn,
        transferOut: balance.transferOut,
        finalBalance: balance.availableBalance
      },
      createdAt: new Date().toISOString(),
      autoGenerated: true
    };
    
    carryOvers.push(carryOver);
  }
  
  // Save to KV store
  await kv.set(`carryovers:${toMonth}`, carryOvers);
  
  return carryOvers;
}

/**
 * Get or generate carry overs for a month
 */
async function getCarryOvers(monthKey: string): Promise<CarryOverEntry[]> {
  // Check if already exists
  let carryOvers = await kv.get(`carryovers:${monthKey}`);
  
  if (!carryOvers || carryOvers.length === 0) {
    // Auto-generate from previous month
    const prevMonth = getPreviousMonth(monthKey);
    
    // Check if previous month has data (check if budget exists)
    const prevBudgetKey = `budget:${prevMonth}`;
    const prevBudget = await kv.get(prevBudgetKey);
    
    // Only generate if previous month has data
    if (prevBudget || prevMonth) {
      // Check if previous month has any pockets
      const prevPockets = await kv.get(`pockets:${prevMonth}`);
      if (prevPockets && prevPockets.length > 0) {
        carryOvers = await generateCarryOvers(prevMonth, monthKey);
      } else {
        carryOvers = [];
      }
    } else {
      carryOvers = [];
    }
  }
  
  return carryOvers || [];
}

// ============================================
// SMART SUGGESTIONS - HELPER FUNCTIONS
// ============================================

/**
 * Generate smart suggestions for a month
 */
async function generateSuggestions(monthKey: string): Promise<Suggestion[]> {
  const suggestions: Suggestion[] = [];
  
  // Get all data
  const pockets = await getPockets(monthKey);
  const budgetKey = `budget:${monthKey}`;
  const budget = await kv.get(budgetKey) || { initialBudget: 0 };
  
  // Calculate balances for all pockets
  const balances = await Promise.all(
    pockets.map(async (p: Pocket) => ({
      pocket: p,
      balance: await calculatePocketBalance(p.id, monthKey)
    }))
  );
  
  // 1. Suggest transfer from high balance to low balance
  const highBalance = balances.filter(b => b.balance.availableBalance > 1000000);
  const lowBalance = balances.filter(b => b.balance.availableBalance < 100000 && b.balance.availableBalance > 0);
  
  if (highBalance.length > 0 && lowBalance.length > 0) {
    suggestions.push({
      id: `suggest_transfer_${Date.now()}`,
      type: 'transfer',
      title: 'Transfer Antar Kantong',
      message: `${highBalance[0].pocket.name} punya saldo tinggi (Rp ${highBalance[0].balance.availableBalance.toLocaleString('id-ID')}). Pertimbangkan transfer ke ${lowBalance[0].pocket.name}?`,
      priority: 'medium',
      actionable: true,
      action: {
        label: 'Transfer Sekarang',
        endpoint: '/transfer',
        params: {
          fromPocketId: highBalance[0].pocket.id,
          toPocketId: lowBalance[0].pocket.id,
          suggestedAmount: Math.min(500000, Math.floor(highBalance[0].balance.availableBalance * 0.2))
        }
      }
    });
  }
  
  // 2. Suggest archiving empty custom pockets
  const emptyCustomPockets = balances.filter(
    b => b.balance.availableBalance === 0 && 
    b.pocket.type === 'custom' &&
    b.pocket.status !== 'archived'
  );
  
  if (emptyCustomPockets.length > 0) {
    suggestions.push({
      id: `suggest_archive_${Date.now()}`,
      type: 'archive',
      title: 'Archive Kantong Kosong',
      message: `${emptyCustomPockets.length} kantong custom kosong. Archive untuk merapikan daftar?`,
      priority: 'low',
      actionable: true,
      action: {
        label: 'Lihat Kantong',
        params: { pocketIds: emptyCustomPockets.map(b => b.pocket.id) }
      }
    });
  }
  
  // 3. Budget health warning
  const totalBalance = balances.reduce((sum, b) => sum + b.balance.availableBalance, 0);
  const totalBudget = budget.initialBudget || 0;
  
  if (totalBudget > 0) {
    const remainingPercentage = (totalBalance / totalBudget) * 100;
    
    if (remainingPercentage < 20) {
      suggestions.push({
        id: `warn_low_budget_${Date.now()}`,
        type: 'warning',
        title: 'Saldo Menipis',
        message: `Sisa ${remainingPercentage.toFixed(0)}% dari budget awal. Pertimbangkan untuk mengurangi pengeluaran.`,
        priority: 'high',
        actionable: false
      });
    }
  }
  
  // 4. Negative balance warning
  const negativeBalance = balances.filter(b => b.balance.availableBalance < 0);
  
  if (negativeBalance.length > 0) {
    suggestions.push({
      id: `warn_negative_${Date.now()}`,
      type: 'warning',
      title: 'Kantong Defisit',
      message: `${negativeBalance.length} kantong defisit (saldo negatif). Segera tambah dana atau kurangi pengeluaran!`,
      priority: 'high',
      actionable: true,
      action: {
        label: 'Lihat Detail',
        params: { pocketIds: negativeBalance.map(b => b.pocket.id) }
      },
      metadata: {
        totalDeficit: negativeBalance.reduce((sum, b) => sum + Math.abs(b.balance.availableBalance), 0)
      }
    });
  }
  
  // 5. Info: Healthy budget
  if (totalBudget > 0 && totalBalance / totalBudget > 0.5 && negativeBalance.length === 0) {
    suggestions.push({
      id: `info_healthy_${Date.now()}`,
      type: 'info',
      title: 'Budget Sehat',
      message: `Budget masih ${((totalBalance / totalBudget) * 100).toFixed(0)}% tersisa. Pengeluaran terkendali! üëç`,
      priority: 'low',
      actionable: false
    });
  }
  
  return suggestions;
}

/**
 * Calculate budget health score
 */
async function calculateBudgetHealth(monthKey: string): Promise<BudgetHealth> {
  const pockets = await getPockets(monthKey);
  const budgetKey = `budget:${monthKey}`;
  const budget = await kv.get(budgetKey) || { initialBudget: 0 };
  
  // Calculate balances
  const balances = await Promise.all(
    pockets.map(async (p: Pocket) => await calculatePocketBalance(p.id, monthKey))
  );
  
  const totalBalance = balances.reduce((sum, b) => sum + b.availableBalance, 0);
  const totalBudget = budget.initialBudget || 1;
  const totalExpenses = balances.reduce((sum, b) => sum + b.expenses, 0);
  
  let score = 100;
  const issues: string[] = [];
  const strengths: string[] = [];
  
  // Check 1: Balance remaining
  const remainingPercentage = (totalBalance / totalBudget) * 100;
  if (remainingPercentage < 10) {
    score -= 30;
    issues.push('Saldo sangat tipis (< 10%)');
  } else if (remainingPercentage < 30) {
    score -= 15;
    issues.push('Saldo menipis (< 30%)');
  } else if (remainingPercentage > 50) {
    strengths.push('Saldo masih aman (> 50%)');
  }
  
  // Check 2: Negative balance pockets
  const negativeCount = balances.filter(b => b.availableBalance < 0).length;
  if (negativeCount > 0) {
    score -= negativeCount * 20;
    issues.push(`${negativeCount} kantong defisit`);
  } else {
    strengths.push('Tidak ada kantong defisit');
  }
  
  // Check 3: Spending rate
  const spendingRate = totalExpenses / totalBudget;
  if (spendingRate > 0.8) {
    score -= 20;
    issues.push('Pengeluaran tinggi (> 80% budget)');
  } else if (spendingRate < 0.5) {
    strengths.push('Pengeluaran terkendali (< 50% budget)');
  }
  
  // Determine status
  let status: BudgetHealth['status'] = 'healthy';
  if (score < 40) {
    status = 'critical';
  } else if (score < 70) {
    status = 'warning';
  }
  
  return {
    status,
    score: Math.max(0, Math.min(100, score)),
    issues,
    strengths
  };
}

// ============================================
// TIMELINE SYSTEM - HELPER FUNCTIONS
// ============================================

/**
 * Generate timeline entries for a pocket
 * Includes: initial balance, income, expenses, and transfers
 */
function generatePocketTimeline(
  pocketId: string,
  monthKey: string,
  sortOrder: 'asc' | 'desc',
  sharedData: any
): TimelineEntry[] {
  const { budget, expenses, additionalIncome, transfers, excludeState, pockets, carryOvers } = sharedData;
  
  const excludedExpenseIds = new Set(excludeState.excludedExpenseIds || []);
  const excludedIncomeIds = new Set(excludeState.excludedIncomeIds || []);
  
  // Get pocket info
  const pocket = pockets.find((p: Pocket) => p.id === pocketId);
  const pocketName = pocket?.name || 'Unknown Pocket';
  
  // Simple approach: collect all transactions, then sort and calculate balance
  // No special handling - Budget Awal is just another income transaction
  const allTransactions: any[] = [];
  
  // 1. Add initial balance as income transaction (if applicable)
  if (pocketId === POCKET_IDS.DAILY) {
    // Sehari-hari: Budget Awal = initialBudget + carryover
    const budgetData = budget || { initialBudget: 0, carryover: 0 };
    const initialAmount = (budgetData.initialBudget || 0) + (budgetData.carryover || 0);
    
    if (initialAmount !== 0) {
      allTransactions.push({
        id: `initial_${pocketId}`,
        type: 'income',
        date: `${monthKey}-01T00:00:00.000Z`,
        description: 'Budget Awal',
        amount: initialAmount,
        icon: 'Wallet',
        color: 'green',
        metadata: {
          initialBudget: budgetData.initialBudget,
          carryover: budgetData.carryover,
          isPrimaryPocket: true
        }
      });
    }
  } else if (pocketId === POCKET_IDS.COLD_MONEY) {
    // Uang Dingin: no initial entry, all income shown separately
  } else {
    // Custom pockets: Saldo Awal from carry over
    const carryOver = carryOvers.find((co: any) => co.pocketId === pocketId);
    if (carryOver && carryOver.amount !== 0) {
      allTransactions.push({
        id: `initial_${pocketId}`,
        type: 'income',
        date: `${monthKey}-01T00:00:00.000Z`,
        description: 'Saldo Awal (Carry Over)',
        amount: carryOver.amount,
        icon: 'TrendingUp',
        color: 'green',
        metadata: {
          fromMonth: carryOver.fromMonth,
          breakdown: carryOver.breakdown
        }
      });
    }
  }
  
  // 2. Expenses for this pocket
  const pocketExpenses = expenses
    .filter((e: any) => e.pocketId === pocketId && !excludedExpenseIds.has(e.id))
    .map((e: any) => ({
      id: e.id,
      type: 'expense' as TransactionType,
      date: e.date,
      description: e.name,
      amount: -e.amount,
      icon: e.categoryIcon || 'ShoppingBag',
      color: 'red',
      metadata: {
        category: e.category,
        notes: e.notes,
        groupId: e.groupId
      }
    }));
  
  // 3. Additional income (for Cold Money pocket)
  // Backward compatibility: if pocketId is undefined, default to Cold Money pocket
  const pocketIncome = additionalIncome
    .filter((i: any) => {
      const incomePoketId = i.pocketId || POCKET_IDS.COLD_MONEY;
      return incomePoketId === pocketId && !excludedIncomeIds.has(i.id);
    })
    .map((i: any) => ({
      id: i.id,
      type: 'income' as TransactionType,
      date: i.date,
      description: i.name,
      amount: i.amountIDR - i.deduction,
      icon: 'DollarSign',
      color: 'green',
      metadata: {
        amountUSD: i.amountUSD,
        exchangeRate: i.exchangeRate,
        deduction: i.deduction
      }
    }));
  
  // 4. Transfers - show both incoming and outgoing
  const pocketTransfers: any[] = [];
  
  transfers.forEach((t: any) => {
    // Transfer OUT (from this pocket)
    if (t.fromPocketId === pocketId) {
      // BACKWARD COMPATIBILITY: Use stored name if available, otherwise lookup from pockets array
      const toPocket = pockets.find((p: Pocket) => p.id === t.toPocketId);
      const toPocketName = t.toPocketName || toPocket?.name || 'Unknown Pocket';
      
      pocketTransfers.push({
        id: `${t.id}_out`,
        type: 'transfer' as TransactionType,
        date: t.date,
        description: `Transfer ke ${toPocketName}`,
        amount: -t.amount,
        icon: 'ArrowRight',
        color: 'blue',
        metadata: {
          transferId: t.id,
          direction: 'out',
          fromPocketId: t.fromPocketId,
          toPocketId: t.toPocketId,
          toPocketName: toPocketName,
          note: t.note
        }
      });
    }
    
    // Transfer IN (to this pocket)
    if (t.toPocketId === pocketId) {
      // BACKWARD COMPATIBILITY: Use stored name if available, otherwise lookup from pockets array
      const fromPocket = pockets.find((p: Pocket) => p.id === t.fromPocketId);
      const fromPocketName = t.fromPocketName || fromPocket?.name || 'Unknown Pocket';
      
      pocketTransfers.push({
        id: `${t.id}_in`,
        type: 'transfer' as TransactionType,
        date: t.date,
        description: `Transfer dari ${fromPocketName}`,
        amount: t.amount,
        icon: 'ArrowLeft',
        color: 'green',
        metadata: {
          transferId: t.id,
          direction: 'in',
          fromPocketId: t.fromPocketId,
          toPocketId: t.toPocketId,
          fromPocketName: fromPocketName,
          note: t.note
        }
      });
    }
  });
  
  // Add expenses, income, and transfers
  allTransactions.push(...pocketExpenses);
  allTransactions.push(...pocketIncome);
  allTransactions.push(...pocketTransfers);
  
  // Sort by date ASCENDING (oldest first) - always calculate forward
  allTransactions.sort((a, b) => {
    const dateA = new Date(a.date).getTime();
    const dateB = new Date(b.date).getTime();
    return dateA - dateB;  // ASC
  });
  
  // Calculate balance FORWARD (simple and correct)
  let runningBalance = 0;
  const entries: TimelineEntry[] = [];
  
  allTransactions.forEach(txn => {
    runningBalance += txn.amount;
    entries.push({
      ...txn,
      balanceAfter: runningBalance
    });
  });
  
  // If user wants DESC, reverse the array
  if (sortOrder === 'desc') {
    entries.reverse();
  }
  
  return entries;
}

// ============================================
// ARCHIVE SYSTEM - HELPER FUNCTIONS
// ============================================

/**
 * Archive a pocket (must have balance = 0)
 */
async function archivePocket(request: ArchiveRequest): Promise<ArchiveResult> {
  const { pocketId, monthKey, reason } = request;
  
  // 1. Get current pockets
  const pockets = await getPockets(monthKey);
  const pocket = pockets.find((p: Pocket) => p.id === pocketId);
  
  if (!pocket) {
    throw new Error('Pocket not found');
  }
  
  if (pocket.status === 'archived') {
    throw new Error('Pocket already archived');
  }
  
  if (pocket.type === 'primary') {
    throw new Error('Cannot archive primary pockets (Sehari-hari, Uang Dingin)');
  }
  
  // 2. Check balance MUST be 0
  const balance = await calculatePocketBalance(pocketId, monthKey);
  
  if (balance.availableBalance !== 0) {
    throw new Error(
      `Saldo harus Rp 0 sebelum archive. Saldo saat ini: Rp ${balance.availableBalance.toLocaleString('id-ID')}`
    );
  }
  
  // 3. Update pocket status
  pocket.status = 'archived';
  pocket.archivedAt = new Date().toISOString();
  pocket.archivedReason = reason || 'Tidak ada alasan';
  
  // 4. Remove from active pockets list
  const activePockets = pockets.filter((p: Pocket) => p.id !== pocketId);
  await kv.set(`pockets:${monthKey}`, activePockets);
  
  // 5. Save to archived pockets (global, not per month)
  const archivedKey = 'archived_pockets';
  const archived = await kv.get(archivedKey) || [];
  archived.push(pocket);
  await kv.set(archivedKey, archived);
  
  // 6. Log to archive history
  const historyKey = 'archive_history';
  const history = await kv.get(historyKey) || [];
  const historyEntry: ArchiveHistoryEntry = {
    pocketId: pocket.id,
    pocketName: pocket.name,
    archivedAt: pocket.archivedAt,
    reason: pocket.archivedReason,
    balanceAtArchive: balance.availableBalance
  };
  history.push(historyEntry);
  await kv.set(historyKey, history);
  
  return {
    success: true,
    archivedPocket: pocket,
    message: `Kantong "${pocket.name}" berhasil diarsipkan`
  };
}

/**
 * Unarchive a pocket (restore to active)
 */
async function unarchivePocket(pocketId: string, monthKey: string): Promise<ArchiveResult> {
  // 1. Get archived pockets
  const archivedKey = 'archived_pockets';
  const archived = await kv.get(archivedKey) || [];
  const pocket = archived.find((p: Pocket) => p.id === pocketId);
  
  if (!pocket) {
    throw new Error('Archived pocket not found');
  }
  
  // 2. Restore pocket
  pocket.status = 'active';
  delete pocket.archivedAt;
  delete pocket.archivedReason;
  
  // 3. Remove from archived list
  const remainingArchived = archived.filter((p: Pocket) => p.id !== pocketId);
  await kv.set(archivedKey, remainingArchived);
  
  // 4. Add back to active pockets
  const pockets = await getPockets(monthKey);
  pockets.push(pocket);
  await kv.set(`pockets:${monthKey}`, pockets);
  
  return {
    success: true,
    archivedPocket: pocket,
    message: `Kantong "${pocket.name}" berhasil dipulihkan`
  };
}

/**
 * Get archived pockets
 */
async function getArchivedPockets(): Promise<Pocket[]> {
  const archivedKey = 'archived_pockets';
  return await kv.get(archivedKey) || [];
}

/**
 * Get archive history
 */
async function getArchiveHistory(): Promise<ArchiveHistoryEntry[]> {
  const historyKey = 'archive_history';
  return await kv.get(historyKey) || [];
}

// REMOVED: Duplicate generatePocketTimeline function (kept the first one at line 604)

/**
 * Validate transfer
 */
function validateTransfer(
  transfer: { fromPocketId: string; toPocketId: string; amount: number },
  fromBalance: PocketBalance
): { valid: boolean; error?: string } {
  if (transfer.fromPocketId === transfer.toPocketId) {
    return { valid: false, error: 'Tidak bisa transfer ke kantong yang sama' };
  }
  
  if (transfer.amount <= 0) {
    return { valid: false, error: 'Jumlah transfer harus lebih dari 0' };
  }
  
  if (fromBalance.availableBalance < transfer.amount) {
    return { 
      valid: false, 
      error: `Saldo tidak cukup. Tersedia: Rp ${fromBalance.availableBalance.toLocaleString('id-ID')}` 
    };
  }
  
  return { valid: true };
}

const app = new Hono();

// Enable logger
app.use('*', logger(console.log));

// Enable CORS for all routes and methods
app.use(
  "/*",
  cors({
    origin: "*",
    allowHeaders: ["Content-Type", "Authorization"],
    allowMethods: ["GET", "POST", "PUT", "DELETE", "OPTIONS"],
    exposeHeaders: ["Content-Length"],
    maxAge: 600,
  }),
);

// Health check endpoint
app.get("/make-server-3adbeaf1/health", (c) => {
  return c.json({ status: "ok" });
});

// Get budget for specific month (with all related data)
app.get("/make-server-3adbeaf1/budget/:year/:month", async (c) => {
  try {
    const year = c.req.param("year");
    const month = c.req.param("month");
    const monthKey = `${year}-${month}`;
    
    // Fetch all data in parallel for better performance
    const [budget, expenses, additionalIncomes, previousMonthRemaining] = await Promise.all([
      kv.get(`budget:${monthKey}`),
      kv.getByPrefix(`expense:${monthKey}:`),
      kv.getByPrefix(`income:${monthKey}:`),
      calculatePreviousMonthRemaining(year, month)
    ]);
    
    return c.json({
      budget: budget || {
        initialBudget: 0,
        carryover: 0,
        notes: "",
        incomeDeduction: 0,
      },
      expenses: expenses || [],
      additionalIncomes: additionalIncomes || [],
      previousMonthRemaining: previousMonthRemaining ?? null
    });
  } catch (error: any) {
    console.log(`Error fetching budget data: ${error.message}`);
    return c.json({ error: `Failed to get budget: ${error.message}` }, 500);
  }
});

// Helper function to calculate previous month remaining
async function calculatePreviousMonthRemaining(year: string, month: string): Promise<number | null> {
  try {
    // Calculate previous month and year
    let prevMonth = parseInt(month) - 1;
    let prevYear = parseInt(year);
    
    if (prevMonth === 0) {
      prevMonth = 12;
      prevYear = prevYear - 1;
    }
    
    const prevMonthKey = `${prevYear}-${prevMonth.toString().padStart(2, '0')}`;
    
    // Fetch previous month data
    const prevBudget = await kv.get(`budget:${prevMonthKey}`) || { initialBudget: 0, carryover: 0, incomeDeduction: 0 };
    const prevExpenses = await kv.getByPrefix(`expense:${prevMonthKey}:`) || [];
    const prevIncomes = await kv.getByPrefix(`income:${prevMonthKey}:`) || [];
    
    // Calculate previous month remaining
    const prevGrossIncome = prevIncomes.reduce((sum: number, income: any) => sum + (income.amountIDR || 0), 0);
    const prevTotalAdditionalIncome = prevGrossIncome - (prevBudget.incomeDeduction || 0);
    const prevTotalIncome = Number(prevBudget.initialBudget || 0) + Number(prevBudget.carryover || 0) + prevTotalAdditionalIncome;
    const prevTotalExpenses = prevExpenses.reduce((sum: number, expense: any) => sum + (expense.amount || 0), 0);
    const remaining = prevTotalIncome - prevTotalExpenses;
    
    return remaining;
  } catch (error) {
    console.log(`Error calculating previous month remaining: ${error}`);
    return null;
  }
}

// Save/update budget for specific month
app.post("/make-server-3adbeaf1/budget/:year/:month", async (c) => {
  try {
    const year = c.req.param("year");
    const month = c.req.param("month");
    const key = `budget:${year}-${month}`;
    
    const body = await c.req.json();
    const { initialBudget, carryover, notes, incomeDeduction } = body;
    
    const budgetData = {
      initialBudget: Number(initialBudget) || 0,
      carryover: Number(carryover) || 0,
      notes: notes || "",
      incomeDeduction: Number(incomeDeduction) || 0,
      updatedAt: new Date().toISOString(),
    };
    
    await kv.set(key, budgetData);
    
    return c.json({ success: true, data: budgetData });
  } catch (error: any) {
    return c.json({ error: `Failed to save budget: ${error.message}` }, 500);
  }
});

// Get all expenses for specific month
app.get("/make-server-3adbeaf1/expenses/:year/:month", async (c) => {
  try {
    const year = c.req.param("year");
    const month = c.req.param("month");
    const prefix = `expense:${year}-${month}:`;
    
    const expenses = await kv.getByPrefix(prefix);
    
    return c.json(expenses || []);
  } catch (error: any) {
    return c.json({ error: `Failed to get expenses: ${error.message}` }, 500);
  }
});

// Add new expense
app.post("/make-server-3adbeaf1/expenses/:year/:month", async (c) => {
  try {
    const year = c.req.param("year");
    const month = c.req.param("month");
    const body = await c.req.json();
    
    const { name, amount, date, items, color, fromIncome, currency, originalAmount, exchangeRate, conversionType, deduction, pocketId, groupId, category } = body;
    
    if (!name || amount === undefined) {
      return c.json({ error: "Name and amount are required" }, 400);
    }
    
    const expenseId = crypto.randomUUID();
    const key = `expense:${year}-${month}:${expenseId}`;
    
    console.log(`[Add Single Expense] Received date: ${date} | Name: ${name}`);
    
    // Parse date: if date is in YYYY-MM-DD format, add time at noon to avoid timezone issues
    let expenseDate;
    if (date) {
      if (date.includes('T')) {
        // Already has time component
        expenseDate = date;
      } else {
        // Just a date (YYYY-MM-DD)
        // CRITICAL FIX: Use noon (12:00) instead of current time to avoid timezone shift
        // This ensures the date stays consistent regardless of timezone
        expenseDate = `${date}T12:00:00.000Z`;
      }
    } else {
      expenseDate = new Date().toISOString();
    }
    
    console.log(`[Add Single Expense] Final date stored: ${expenseDate}`);
    
    const expenseData = {
      id: expenseId,
      name,
      amount: Number(amount),
      date: expenseDate,
      pocketId: pocketId || POCKET_IDS.DAILY, // Default to daily pocket
      ...(items && items.length > 0 ? { items } : {}),
      ...(color ? { color } : {}),
      ...(fromIncome ? { fromIncome: true } : {}),
      ...(currency ? { currency } : {}),
      ...(originalAmount !== undefined ? { originalAmount: Number(originalAmount) } : {}),
      ...(exchangeRate !== undefined ? { exchangeRate: Number(exchangeRate) } : {}),
      ...(conversionType ? { conversionType } : {}),
      ...(deduction !== undefined ? { deduction: Number(deduction) } : {}),
      ...(groupId ? { groupId } : {}),
      ...(category ? { category } : {}),
      createdAt: new Date().toISOString(),
    };
    
    await kv.set(key, expenseData);
    
    return c.json({ success: true, data: expenseData });
  } catch (error: any) {
    return c.json({ error: `Failed to add expense: ${error.message}` }, 500);
  }
});

// Add multiple expenses at once (batch)
app.post("/make-server-3adbeaf1/expenses/:year/:month/batch", async (c) => {
  try {
    const year = c.req.param("year");
    const month = c.req.param("month");
    const body = await c.req.json();
    
    const { expenses } = body;
    
    if (!Array.isArray(expenses) || expenses.length === 0) {
      return c.json({ error: "Expenses array is required" }, 400);
    }
    
    const addedExpenses = [];
    const currentTime = new Date();
    
    console.log(`[Add Batch Expenses] Processing ${expenses.length} expenses`);
    
    for (const expense of expenses) {
      const { name, amount, date, items, color, fromIncome, currency, originalAmount, exchangeRate, conversionType, deduction, pocketId, groupId, category } = expense;
      
      if (!name || amount === undefined) {
        continue; // Skip invalid entries
      }
      
      const expenseId = crypto.randomUUID();
      const key = `expense:${year}-${month}:${expenseId}`;
      
      console.log(`[Batch Item] Received date: ${date} | Name: ${name}`);
      
      // Parse date: if date is in YYYY-MM-DD format, add time at noon to avoid timezone issues
      let expenseDate;
      if (date) {
        if (date.includes('T')) {
          expenseDate = date;
        } else {
          // CRITICAL FIX: Use noon (12:00) instead of current time to avoid timezone shift
          // This ensures the date stays consistent regardless of timezone
          expenseDate = `${date}T12:00:00.000Z`;
        }
      } else {
        expenseDate = currentTime.toISOString();
      }
      
      const expenseData = {
        id: expenseId,
        name,
        amount: Number(amount),
        date: expenseDate,
        pocketId: pocketId || POCKET_IDS.DAILY,
        ...(items && items.length > 0 ? { items } : {}),
        ...(color ? { color } : {}),
        ...(fromIncome ? { fromIncome: true } : {}),
        ...(currency ? { currency } : {}),
        ...(originalAmount !== undefined ? { originalAmount: Number(originalAmount) } : {}),
        ...(exchangeRate !== undefined ? { exchangeRate: Number(exchangeRate) } : {}),
        ...(conversionType ? { conversionType } : {}),
        ...(deduction !== undefined ? { deduction: Number(deduction) } : {}),
        ...(groupId ? { groupId } : {}),
        ...(category ? { category } : {}),
        createdAt: currentTime.toISOString(),
      };
      
      await kv.set(key, expenseData);
      addedExpenses.push(expenseData);
    }
    
    return c.json({ success: true, data: addedExpenses, count: addedExpenses.length });
  } catch (error: any) {
    return c.json({ error: `Failed to add expenses: ${error.message}` }, 500);
  }
});

// Delete expense
app.delete("/make-server-3adbeaf1/expenses/:year/:month/:id", async (c) => {
  try {
    const year = c.req.param("year");
    const month = c.req.param("month");
    const id = c.req.param("id");
    const key = `expense:${year}-${month}:${id}`;
    
    await kv.del(key);
    
    return c.json({ success: true });
  } catch (error: any) {
    return c.json({ error: `Failed to delete expense: ${error.message}` }, 500);
  }
});

// Update expense
app.put("/make-server-3adbeaf1/expenses/:year/:month/:id", async (c) => {
  try {
    const year = c.req.param("year");
    const month = c.req.param("month");
    const id = c.req.param("id");
    const key = `expense:${year}-${month}:${id}`;
    const body = await c.req.json();
    
    const { name, amount, date, items, color, fromIncome, currency, originalAmount, exchangeRate, conversionType, deduction, pocketId, groupId, category } = body;
    
    if (!name || amount === undefined) {
      return c.json({ error: "Name and amount are required" }, 400);
    }
    
    // Get existing expense to preserve createdAt, pocketId, and groupId if not provided
    const existingExpense = await kv.get(key);
    
    console.log(`[Edit Expense ${id}] Received date:`, date, '| Existing date:', existingExpense?.date);
    
    // Parse date: if date is in YYYY-MM-DD format, preserve the original time or add current time
    let expenseDate;
    let dateChanged = false;
    if (date) {
      if (date.includes('T')) {
        // Already has time component
        expenseDate = date;
        // Check if date changed (compare date part only)
        if (existingExpense?.date) {
          const oldDateOnly = existingExpense.date.split('T')[0];
          const newDateOnly = date.split('T')[0];
          dateChanged = oldDateOnly !== newDateOnly;
        }
      } else {
        // Just a date (YYYY-MM-DD), use the new date but preserve time component from existing expense if available
        // Check if date changed
        if (existingExpense?.date) {
          const oldDateOnly = existingExpense.date.split('T')[0];
          dateChanged = oldDateOnly !== date;
        }
        
        if (existingExpense?.date && existingExpense.date.includes('T')) {
          // Extract time from existing expense, apply to new date
          const existingDate = new Date(existingExpense.date);
          // Parse the new date as YYYY-MM-DD and combine with existing time
          // Use UTC parsing to avoid timezone shifts: "2024-11-06" -> parse as local date at midnight
          const [year, month, day] = date.split('-').map(Number);
          const newDateObj = new Date(year, month - 1, day); // Local timezone date at midnight
          newDateObj.setHours(existingDate.getHours());
          newDateObj.setMinutes(existingDate.getMinutes());
          newDateObj.setSeconds(existingDate.getSeconds());
          newDateObj.setMilliseconds(existingDate.getMilliseconds());
          expenseDate = newDateObj.toISOString();
        } else {
          // Add current time to the new date
          const currentTime = new Date();
          const [year, month, day] = date.split('-').map(Number);
          const dateObj = new Date(year, month - 1, day); // Local timezone date at midnight
          dateObj.setHours(currentTime.getHours());
          dateObj.setMinutes(currentTime.getMinutes());
          dateObj.setSeconds(currentTime.getSeconds());
          expenseDate = dateObj.toISOString();
        }
      }
    } else {
      expenseDate = existingExpense?.date || new Date().toISOString();
    }
    
    // If date changed, remove groupId to ungroup this expense from others
    // Otherwise preserve groupId if it exists
    let finalGroupId;
    if (groupId !== undefined) {
      // Explicitly setting groupId (from frontend)
      finalGroupId = groupId;
    } else if (dateChanged) {
      // Date changed - remove groupId to ungroup
      console.log(`[Edit Expense ${id}] Date changed! Removing groupId. Old groupId:`, existingExpense?.groupId);
      finalGroupId = undefined;
    } else {
      // Date didn't change - preserve existing groupId
      finalGroupId = existingExpense?.groupId;
    }
    
    console.log(`[Edit Expense ${id}] Final expense date:`, expenseDate, '| Date changed:', dateChanged, '| GroupId:', finalGroupId);
    
    const expenseData = {
      id,
      name,
      amount: Number(amount),
      date: expenseDate,
      pocketId: pocketId || existingExpense?.pocketId || POCKET_IDS.DAILY,
      ...(items && items.length > 0 ? { items } : {}),
      ...(color ? { color } : {}),
      ...(fromIncome ? { fromIncome: true } : {}),
      ...(currency ? { currency } : {}),
      ...(originalAmount !== undefined ? { originalAmount: Number(originalAmount) } : {}),
      ...(exchangeRate !== undefined ? { exchangeRate: Number(exchangeRate) } : {}),
      ...(conversionType ? { conversionType } : {}),
      ...(deduction !== undefined ? { deduction: Number(deduction) } : {}),
      ...(finalGroupId ? { groupId: finalGroupId } : {}),
      ...(category ? { category } : {}),
      createdAt: existingExpense?.createdAt || new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    };
    
    await kv.set(key, expenseData);
    
    return c.json({ success: true, data: expenseData });
  } catch (error: any) {
    return c.json({ error: `Failed to update expense: ${error.message}` }, 500);
  }
});

// Get all additional incomes for specific month
app.get("/make-server-3adbeaf1/additional-income/:year/:month", async (c) => {
  try {
    const year = c.req.param("year");
    const month = c.req.param("month");
    const prefix = `income:${year}-${month}:`;
    
    const incomes = await kv.getByPrefix(prefix);
    
    return c.json(incomes || []);
  } catch (error: any) {
    return c.json({ error: `Failed to get additional incomes: ${error.message}` }, 500);
  }
});

// Add new additional income
app.post("/make-server-3adbeaf1/additional-income/:year/:month", async (c) => {
  try {
    const year = c.req.param("year");
    const month = c.req.param("month");
    const body = await c.req.json();
    
    const { name, amount, currency, exchangeRate, amountIDR, conversionType, date, deduction, pocketId } = body;
    

    
    if (!name || amount === undefined) {
      return c.json({ error: "Name and amount are required" }, 400);
    }
    
    if (!pocketId) {
      return c.json({ error: "Pocket ID is required" }, 400);
    }
    
    const incomeId = crypto.randomUUID();
    const key = `income:${year}-${month}:${incomeId}`;
    
    // Parse date: if date is in YYYY-MM-DD format, use UTC noon standard
    let incomeDate;
    if (date) {
      if (date.includes('T')) {
        // Already has time component
        incomeDate = date;
      } else {
        // Just a date (YYYY-MM-DD), use UTC noon to avoid timezone issues
        incomeDate = `${date}T12:00:00.000Z`;
      }
    } else {
      incomeDate = new Date().toISOString();
    }
    
    const incomeData = {
      id: incomeId,
      name,
      amount: Number(amount),
      currency: currency || "IDR",
      exchangeRate: exchangeRate ? Number(exchangeRate) : null,
      amountIDR: Number(amountIDR),
      conversionType: conversionType || "manual",
      date: incomeDate,
      deduction: Number(deduction) || 0,
      pocketId,
      createdAt: new Date().toISOString(),
    };
    
    await kv.set(key, incomeData);
    
    // Store income name for autocomplete suggestions
    const nameKey = `income-name:${name.toLowerCase()}`;
    await kv.set(nameKey, { name, lastUsed: new Date().toISOString() });
    
    return c.json({ success: true, data: incomeData });
  } catch (error: any) {
    return c.json({ error: `Failed to add additional income: ${error.message}` }, 500);
  }
});

// Delete additional income
app.delete("/make-server-3adbeaf1/additional-income/:year/:month/:id", async (c) => {
  try {
    const year = c.req.param("year");
    const month = c.req.param("month");
    const id = c.req.param("id");
    const key = `income:${year}-${month}:${id}`;
    
    await kv.del(key);
    
    return c.json({ success: true });
  } catch (error: any) {
    return c.json({ error: `Failed to delete additional income: ${error.message}` }, 500);
  }
});

// Update additional income
app.put("/make-server-3adbeaf1/additional-income/:year/:month/:id", async (c) => {
  try {
    const year = c.req.param("year");
    const month = c.req.param("month");
    const id = c.req.param("id");
    const key = `income:${year}-${month}:${id}`;
    const body = await c.req.json();
    
    const { name, amount, currency, exchangeRate, amountIDR, conversionType, date, deduction, pocketId } = body;
    
    if (!name || amount === undefined) {
      return c.json({ error: "Name and amount are required" }, 400);
    }
    
    // Get existing data to preserve createdAt and pocketId
    const existingIncome = await kv.get(key);
    
    // Use provided pocketId, or fallback to existing pocketId, or default to cold money
    const finalPocketId = pocketId || existingIncome?.pocketId || POCKET_IDS.COLD_MONEY;
    
    // Parse date: if date is in YYYY-MM-DD format, use UTC noon standard
    let incomeDate;
    if (date) {
      if (date.includes('T')) {
        // Already has time component
        incomeDate = date;
      } else {
        // Just a date (YYYY-MM-DD), use UTC noon to avoid timezone issues
        incomeDate = `${date}T12:00:00.000Z`;
      }
    } else {
      incomeDate = existingIncome?.date || new Date().toISOString();
    }
    
    const incomeData = {
      id,
      name,
      amount: Number(amount),
      currency: currency || "IDR",
      exchangeRate: exchangeRate ? Number(exchangeRate) : null,
      amountIDR: Number(amountIDR),
      conversionType: conversionType || "manual",
      date: incomeDate,
      deduction: Number(deduction) || 0,
      pocketId: finalPocketId,
      createdAt: existingIncome?.createdAt || new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    };
    
    await kv.set(key, incomeData);
    
    // Update income name for autocomplete suggestions
    const nameKey = `income-name:${name.toLowerCase()}`;
    await kv.set(nameKey, { name, lastUsed: new Date().toISOString() });
    
    return c.json({ success: true, data: incomeData });
  } catch (error: any) {
    return c.json({ error: `Failed to update additional income: ${error.message}` }, 500);
  }
});

// Get income name suggestions
app.get("/make-server-3adbeaf1/income-names", async (c) => {
  try {
    const prefix = "income-name:";
    const names = await kv.getByPrefix(prefix);
    
    // Sort by last used
    const sortedNames = (names || [])
      .sort((a, b) => new Date(b.lastUsed).getTime() - new Date(a.lastUsed).getTime())
      .map(item => item.name);
    
    return c.json(sortedNames);
  } catch (error: any) {
    return c.json({ error: `Failed to get income names: ${error.message}` }, 500);
  }
});

// Get exchange rate from USD to IDR
app.get("/make-server-3adbeaf1/exchange-rate", async (c) => {
  try {
    const apiKey = Deno.env.get("EXCHANGE_RATE_API_KEY");
    
    if (!apiKey) {
      return c.json({ error: "Exchange rate API key not configured" }, 500);
    }
    
    const response = await fetch(
      `https://v6.exchangerate-api.com/v6/${apiKey}/pair/USD/IDR`
    );
    
    if (!response.ok) {
      throw new Error("Failed to fetch exchange rate from API");
    }
    
    const data = await response.json();
    
    if (data.result !== "success") {
      throw new Error("Exchange rate API returned error");
    }
    
    return c.json({ 
      rate: data.conversion_rate,
      lastUpdated: data.time_last_update_utc 
    });
  } catch (error: any) {
    return c.json({ error: `Failed to get exchange rate: ${error.message}` }, 500);
  }
});

// Get all fixed expense templates
app.get("/make-server-3adbeaf1/templates", async (c) => {
  try {
    const prefix = "template:";
    const templates = await kv.getByPrefix(prefix);
    
    return c.json(templates || []);
  } catch (error: any) {
    return c.json({ error: `Failed to get templates: ${error.message}` }, 500);
  }
});

// Add new fixed expense template
app.post("/make-server-3adbeaf1/templates", async (c) => {
  try {
    const body = await c.req.json();
    const { name, items, color } = body;
    
    if (!name || !items || !Array.isArray(items)) {
      return c.json({ error: "Name and items are required" }, 400);
    }
    
    const templateId = crypto.randomUUID();
    const key = `template:${templateId}`;
    
    const templateData = {
      id: templateId,
      name,
      items,
      ...(color ? { color } : {}),
      createdAt: new Date().toISOString(),
    };
    
    await kv.set(key, templateData);
    
    return c.json({ success: true, data: templateData });
  } catch (error: any) {
    return c.json({ error: `Failed to add template: ${error.message}` }, 500);
  }
});

// Update fixed expense template
app.put("/make-server-3adbeaf1/templates/:id", async (c) => {
  try {
    const id = c.req.param("id");
    const key = `template:${id}`;
    const body = await c.req.json();
    
    const { name, items, color } = body;
    
    if (!name || !items || !Array.isArray(items)) {
      return c.json({ error: "Name and items are required" }, 400);
    }
    
    const templateData = {
      id,
      name,
      items,
      ...(color ? { color } : {}),
      updatedAt: new Date().toISOString(),
    };
    
    await kv.set(key, templateData);
    
    return c.json({ success: true, data: templateData });
  } catch (error: any) {
    return c.json({ error: `Failed to update template: ${error.message}` }, 500);
  }
});

// Delete fixed expense template
app.delete("/make-server-3adbeaf1/templates/:id", async (c) => {
  try {
    const id = c.req.param("id");
    const key = `template:${id}`;
    
    await kv.del(key);
    
    return c.json({ success: true });
  } catch (error: any) {
    return c.json({ error: `Failed to delete template: ${error.message}` }, 500);
  }
});

// Get exclude state for a specific month
app.get("/make-server-3adbeaf1/exclude-state/:year/:month", async (c) => {
  try {
    const year = c.req.param("year");
    const month = c.req.param("month");
    const key = `exclude-state:${year}-${month}`;
    
    const excludeState = await kv.get(key);
    
    if (!excludeState) {
      return c.json({
        locked: false,
        excludedExpenseIds: [],
        excludedIncomeIds: [],
        isDeductionExcluded: false,
      });
    }
    
    return c.json(excludeState);
  } catch (error: any) {
    console.log(`Error loading exclude state: ${error.message}`);
    return c.json({ error: `Failed to get exclude state: ${error.message}` }, 500);
  }
});

// Save/update exclude state for a specific month
app.post("/make-server-3adbeaf1/exclude-state/:year/:month", async (c) => {
  try {
    const year = c.req.param("year");
    const month = c.req.param("month");
    const key = `exclude-state:${year}-${month}`;
    
    const body = await c.req.json();
    const { locked, excludedExpenseIds, excludedIncomeIds, isDeductionExcluded } = body;
    
    const excludeStateData = {
      locked: Boolean(locked),
      excludedExpenseIds: excludedExpenseIds || [],
      excludedIncomeIds: excludedIncomeIds || [],
      isDeductionExcluded: Boolean(isDeductionExcluded),
      updatedAt: new Date().toISOString(),
    };
    
    await kv.set(key, excludeStateData);
    
    return c.json({ success: true, data: excludeStateData });
  } catch (error: any) {
    return c.json({ error: `Failed to save exclude state: ${error.message}` }, 500);
  }
});

// Delete exclude state lock for specific month
app.delete("/make-server-3adbeaf1/exclude-state/:year/:month", async (c) => {
  try {
    const year = c.req.param("year");
    const month = c.req.param("month");
    const key = `exclude-state:${year}-${month}`;
    
    await kv.del(key);
    
    return c.json({ success: true });
  } catch (error: any) {
    return c.json({ error: `Failed to delete exclude state: ${error.message}` }, 500);
  }
});

// ============================================
// POCKETS SYSTEM - ENDPOINTS
// ============================================

// Get pockets and balances for a month
app.get("/make-server-3adbeaf1/pockets/:year/:month", async (c) => {
  try {
    const year = c.req.param("year");
    const month = c.req.param("month");
    const monthKey = `${year}-${month}`;
    
    const pockets = await getPockets(monthKey);
    
    // Fetch shared data once instead of per-pocket
    const [budget, expensesData, additionalIncome, transfers, excludeState] = await Promise.all([
      kv.get(`budget:${monthKey}`),
      kv.getByPrefix(`expense:${monthKey}:`),
      kv.getByPrefix(`income:${monthKey}:`),
      kv.getByPrefix(`transfer:${monthKey}:`),
      kv.get(`exclude-state:${monthKey}`)
    ]);
    
    const sharedData = {
      budget: budget || { initialBudget: 0, carryover: 0 },
      expensesData: expensesData || [],
      additionalIncome: additionalIncome || [],
      transfers: transfers || [],
      excludeState: excludeState || { excludedExpenseIds: [], excludedIncomeIds: [] }
    };
    
    // Calculate balances for all pockets using shared data
    const balances = await Promise.all(
      pockets.map(pocket => calculatePocketBalance(pocket.id, monthKey, sharedData))
    );
    
    return c.json({
      success: true,
      data: {
        pockets,
        balances
      }
    });
  } catch (error: any) {
    return c.json({ error: `Failed to fetch pockets: ${error.message}` }, 500);
  }
});

// Create custom pocket
app.post("/make-server-3adbeaf1/pockets/:year/:month", async (c) => {
  try {
    const year = c.req.param("year");
    const month = c.req.param("month");
    const monthKey = `${year}-${month}`;
    const body = await c.req.json();
    const { name, description, icon, color, enableWishlist } = body;
    
    if (!name) {
      return c.json({ 
        success: false, 
        error: 'Pocket name is required' 
      }, 400);
    }
    
    // Get existing pockets to determine order
    const existingPockets = await getPockets(monthKey);
    const maxOrder = existingPockets.length > 0 
      ? Math.max(...existingPockets.map((p: Pocket) => p.order))
      : 0;
    
    // Create new pocket
    const newPocket: Pocket = {
      id: `pocket_custom_${Date.now()}_${crypto.randomUUID().substring(0, 8)}`,
      name,
      type: 'custom',
      description,
      icon: icon || 'Wallet',
      color: color || 'blue',
      order: maxOrder + 1,
      createdAt: new Date().toISOString(),
      enableWishlist: enableWishlist !== undefined ? enableWishlist : true // Default true for custom pockets
    };
    
    // Save to month-specific pockets list
    const pocketsKey = `pockets:${monthKey}`;
    const allPockets = await kv.get(pocketsKey) || [...DEFAULT_POCKETS];
    allPockets.push(newPocket);
    await kv.set(pocketsKey, allPockets);
    
    return c.json({
      success: true,
      data: newPocket
    });
  } catch (error: any) {
    return c.json({ success: false, error: error.message }, 500);
  }
});

// Update pocket wishlist setting
app.put("/make-server-3adbeaf1/pockets/:year/:month/:pocketId/wishlist-setting", async (c) => {
  try {
    const pocketId = c.req.param("pocketId");
    const year = c.req.param("year");
    const month = c.req.param("month");
    const monthKey = `${year}-${month}`;
    const body = await c.req.json();
    const { enableWishlist } = body;
    
    if (!pocketId) {
      return c.json({ 
        success: false, 
        error: 'Pocket ID is required' 
      }, 400);
    }
    
    if (enableWishlist === undefined) {
      return c.json({ 
        success: false, 
        error: 'enableWishlist is required' 
      }, 400);
    }
    
    // Get pockets for this month - use the correct key!
    const pocketsKey = `pockets:${monthKey}`;
    const allPockets = await kv.get(pocketsKey) || [...DEFAULT_POCKETS];
    
    // Find and update the pocket
    const pocketIndex = allPockets.findIndex((p: Pocket) => p.id === pocketId);
    
    if (pocketIndex === -1) {
      return c.json({ 
        success: false, 
        error: 'Pocket not found' 
      }, 404);
    }
    
    // Update the pocket
    allPockets[pocketIndex] = {
      ...allPockets[pocketIndex],
      enableWishlist: Boolean(enableWishlist)
    };
    
    // Save back to the correct key
    await kv.set(pocketsKey, allPockets);
    
    return c.json({
      success: true,
      data: allPockets[pocketIndex]
    });
  } catch (error: any) {
    return c.json({ success: false, error: error.message }, 500);
  }
});

// Create transfer between pockets
app.post("/make-server-3adbeaf1/transfer/:year/:month", async (c) => {
  try {
    const year = c.req.param("year");
    const month = c.req.param("month");
    const monthKey = `${year}-${month}`;
    const body = await c.req.json();
    const { fromPocketId, toPocketId, amount, date, note } = body;
    
    if (!fromPocketId || !toPocketId || !amount) {
      return c.json({ 
        success: false, 
        error: 'Missing required fields' 
      }, 400);
    }
    
    // Get current balance
    const fromBalance = await calculatePocketBalance(fromPocketId, monthKey);
    
    // Validate transfer
    const validation = validateTransfer(
      { fromPocketId, toPocketId, amount },
      fromBalance
    );
    
    if (!validation.valid) {
      return c.json({ 
        success: false, 
        error: validation.error 
      }, 400);
    }
    
    // Get pockets to preserve pocket names for history (in case pocket gets deleted later)
    const pockets = await getPockets(monthKey);
    const fromPocket = pockets.find((p: Pocket) => p.id === fromPocketId);
    const toPocket = pockets.find((p: Pocket) => p.id === toPocketId);
    
    // Create transfer
    const transferId = `transfer_${Date.now()}_${crypto.randomUUID().substring(0, 8)}`;
    
    // CRITICAL FIX: Parse date to use UTC noon standard to avoid timezone issues
    let transferDate;
    if (date) {
      if (date.includes('T')) {
        transferDate = date;
      } else {
        // Just a date (YYYY-MM-DD), use noon UTC
        transferDate = `${date}T12:00:00.000Z`;
      }
    } else {
      transferDate = new Date().toISOString();
    }
    
    const transfer: TransferTransaction = {
      id: transferId,
      type: 'transfer',
      amount: Number(amount),
      fromPocketId,
      toPocketId,
      fromPocketName: fromPocket?.name, // Preserve name for history
      toPocketName: toPocket?.name,     // Preserve name for history
      date: transferDate,
      note,
      createdAt: new Date().toISOString()
    };
    
    // Save to KV using prefix pattern (FIXED)
    const transferKey = `transfer:${monthKey}:${transferId}`;
    await kv.set(transferKey, transfer);
    
    // Recalculate balances
    const updatedFromBalance = await calculatePocketBalance(fromPocketId, monthKey);
    const updatedToBalance = await calculatePocketBalance(toPocketId, monthKey);
    
    return c.json({
      success: true,
      data: {
        transfer,
        updatedBalances: {
          [fromPocketId]: updatedFromBalance,
          [toPocketId]: updatedToBalance
        }
      }
    });
  } catch (error: any) {
    return c.json({ success: false, error: error.message }, 500);
  }
});

// Delete transfer
app.delete("/make-server-3adbeaf1/transfer/:year/:month/:id", async (c) => {
  try {
    const year = c.req.param("year");
    const month = c.req.param("month");
    const transferId = c.req.param("id");
    const monthKey = `${year}-${month}`;
    
    if (!transferId) {
      return c.json({ success: false, error: 'Missing transfer ID' }, 400);
    }
    
    // Get transfer using prefix pattern (FIXED)
    const transferKey = `transfer:${monthKey}:${transferId}`;
    const transferToDelete = await kv.get(transferKey);
    
    if (!transferToDelete) {
      return c.json({ success: false, error: 'Transfer not found' }, 404);
    }
    
    // Delete transfer
    await kv.del(transferKey);
    
    // Recalculate balances
    const updatedFromBalance = await calculatePocketBalance(transferToDelete.fromPocketId, monthKey);
    const updatedToBalance = await calculatePocketBalance(transferToDelete.toPocketId, monthKey);
    
    return c.json({
      success: true,
      data: {
        deletedId: transferId,
        updatedBalances: {
          [transferToDelete.fromPocketId]: updatedFromBalance,
          [transferToDelete.toPocketId]: updatedToBalance
        }
      }
    });
  } catch (error: any) {
    return c.json({ success: false, error: error.message }, 500);
  }
});

// Get timeline for a pocket
app.get("/make-server-3adbeaf1/timeline/:year/:month/:pocketId", async (c) => {
  try {
    const year = c.req.param("year");
    const month = c.req.param("month");
    const pocketId = c.req.param("pocketId");
    const monthKey = `${year}-${month}`;
    const sortOrder = (c.req.query('sortOrder') || 'desc') as 'asc' | 'desc';
    
    if (!pocketId) {
      return c.json({ success: false, error: 'Missing pocket ID' }, 400);
    }
    
    // Fetch shared data once (same optimization as pockets endpoint)
    const [budget, expenses, additionalIncome, transfers, excludeState, pockets, carryOvers] = await Promise.all([
      kv.get(`budget:${monthKey}`),
      kv.getByPrefix(`expense:${monthKey}:`),
      kv.getByPrefix(`income:${monthKey}:`),
      kv.getByPrefix(`transfer:${monthKey}:`),
      kv.get(`exclude-state:${monthKey}`),
      getPockets(monthKey),
      getCarryOvers(monthKey)
    ]);
    
    const sharedData = {
      budget: budget || { initialBudget: 0, carryover: 0 },
      expenses: expenses || [],
      additionalIncome: additionalIncome || [],
      transfers: transfers || [],
      excludeState: excludeState || { excludedExpenseIds: [], excludedIncomeIds: [] },
      pockets,
      carryOvers
    };
    
    // Generate timeline with shared data
    const entries = generatePocketTimeline(pocketId, monthKey, sortOrder, sharedData);
    
    // Calculate summary
    const summary = {
      totalIncome: entries.filter(e => e.type === 'income').reduce((sum, e) => sum + e.amount, 0),
      totalExpense: Math.abs(entries.filter(e => e.type === 'expense').reduce((sum, e) => sum + e.amount, 0)),
      netTransfer: entries.filter(e => e.type === 'transfer').reduce((sum, e) => sum + e.amount, 0),
      finalBalance: entries.length > 0 ? entries[0].balanceAfter : 0
    };
    
    return c.json({
      success: true,
      data: { entries, summary }
    });
  } catch (error: any) {
    return c.json({ success: false, error: error.message }, 500);
  }
});

// ============================================
// CARRY OVER ENDPOINTS
// ============================================

// Get carry overs for a month
app.get("/make-server-3adbeaf1/carryover/:year/:month", async (c) => {
  try {
    const year = c.req.param("year");
    const month = c.req.param("month");
    const monthKey = `${year}-${month}`;
    
    const carryOvers = await getCarryOvers(monthKey);
    const pockets = await getPockets(monthKey);
    
    // Build summary
    const summary: CarryOverSummary = {
      monthKey,
      pockets: carryOvers.map((co: CarryOverEntry) => {
        const pocket = pockets.find((p: Pocket) => p.id === co.pocketId);
        return {
          pocketId: co.pocketId,
          pocketName: pocket?.name || 'Unknown',
          carryOverAmount: co.amount,
          hasCarryOver: co.amount !== 0,
          fromMonth: co.fromMonth
        };
      }),
      totalCarryOver: carryOvers.reduce((sum: number, co: CarryOverEntry) => sum + co.amount, 0)
    };
    
    return c.json({
      success: true,
      data: {
        carryOvers,
        summary
      }
    });
  } catch (error: any) {
    return c.json({ success: false, error: error.message }, 500);
  }
});

// Generate carry overs manually (for recalculation)
app.post("/make-server-3adbeaf1/carryover/generate", async (c) => {
  try {
    const body = await c.req.json();
    const { fromMonth, toMonth } = body;
    
    if (!fromMonth || !toMonth) {
      return c.json({ 
        success: false, 
        error: 'Missing fromMonth or toMonth' 
      }, 400);
    }
    
    // Generate carry overs
    const carryOvers = await generateCarryOvers(fromMonth, toMonth);
    
    return c.json({
      success: true,
      data: {
        generated: carryOvers,
        message: `Generated ${carryOvers.length} carry over entries from ${fromMonth} to ${toMonth}`
      }
    });
  } catch (error: any) {
    return c.json({ success: false, error: error.message }, 500);
  }
});

// Recalculate carry over for a month (if past month changed)
app.put("/make-server-3adbeaf1/carryover/recalculate/:year/:month", async (c) => {
  try {
    const year = c.req.param("year");
    const month = c.req.param("month");
    const monthKey = `${year}-${month}`;
    const prevMonth = getPreviousMonth(monthKey);
    
    // Delete existing carry overs
    await kv.set(`carryovers:${monthKey}`, []);
    
    // Regenerate
    const carryOvers = await generateCarryOvers(prevMonth, monthKey);
    
    return c.json({
      success: true,
      data: {
        updated: carryOvers,
        message: `Recalculated carry overs for ${monthKey}`
      }
    });
  } catch (error) {
    console.log(`Error recalculating carry overs: ${error}`);
    return c.json({ success: false, error: error.message }, 500);
  }
});

// Get carry over history for a pocket (last N months)
app.get("/make-server-3adbeaf1/carryover/history/:pocketId", async (c) => {
  try {
    const pocketId = c.req.param("pocketId");
    const limit = parseInt(c.req.query('limit') || '12');
    
    // This would require iterating through months
    // For now, return placeholder
    // TODO: Implement proper history tracking
    
    return c.json({
      success: true,
      data: {
        history: [],
        message: 'History endpoint - not fully implemented yet'
      }
    });
  } catch (error) {
    console.log(`Error fetching carry over history: ${error}`);
    return c.json({ success: false, error: error.message }, 500);
  }
});

// ============================================
// TRANSFER ENDPOINTS
// ============================================

// Transfer between pockets
app.post("/make-server-3adbeaf1/transfers/:year/:month", async (c) => {
  try {
    const year = c.req.param("year");
    const month = c.req.param("month");
    const monthKey = `${year}-${month}`;
    const body = await c.req.json();
    
    const { fromPocketId, toPocketId, amount, date, note } = body;
    
    if (!fromPocketId || !toPocketId || !amount) {
      return c.json({ 
        success: false, 
        error: "fromPocketId, toPocketId, and amount are required" 
      }, 400);
    }
    
    if (fromPocketId === toPocketId) {
      return c.json({ 
        success: false, 
        error: "Cannot transfer to the same pocket" 
      }, 400);
    }
    
    if (amount <= 0) {
      return c.json({ 
        success: false, 
        error: "Transfer amount must be positive" 
      }, 400);
    }
    
    console.log(`[Transfer] ${fromPocketId} ‚Üí ${toPocketId}: ${amount} on ${date}`);
    
    // Parse date: if date is in YYYY-MM-DD format, add time at noon
    let transferDate;
    if (date) {
      if (date.includes('T')) {
        transferDate = date;
      } else {
        // Use noon (12:00 UTC) to avoid timezone issues
        transferDate = `${date}T12:00:00.000Z`;
      }
    } else {
      transferDate = new Date().toISOString();
    }
    
    // Create transfer record
    const transferId = crypto.randomUUID();
    const transfer = {
      id: transferId,
      fromPocketId,
      toPocketId,
      amount: Number(amount),
      date: transferDate,
      note: note || null,
      createdAt: new Date().toISOString()
    };
    
    // Save transfer
    const transferKey = `transfer:${monthKey}:${transferId}`;
    await kv.set(transferKey, transfer);
    
    console.log(`[Transfer] Saved: ${transferKey}`);
    
    return c.json({
      success: true,
      data: transfer
    });
  } catch (error: any) {
    console.error(`[Transfer Error]`, error);
    return c.json({ 
      success: false, 
      error: `Failed to create transfer: ${error.message}` 
    }, 500);
  }
});

// Get all transfers for a month
app.get("/make-server-3adbeaf1/transfers/:year/:month", async (c) => {
  try {
    const year = c.req.param("year");
    const month = c.req.param("month");
    const monthKey = `${year}-${month}`;
    
    const transferKeys = await kv.getByPrefix(`transfer:${monthKey}:`);
    const transfers = transferKeys || [];
    
    return c.json({
      success: true,
      data: transfers
    });
  } catch (error: any) {
    return c.json({ 
      success: false, 
      error: `Failed to fetch transfers: ${error.message}` 
    }, 500);
  }
});

// Delete transfer
app.delete("/make-server-3adbeaf1/transfers/:year/:month/:id", async (c) => {
  try {
    const year = c.req.param("year");
    const month = c.req.param("month");
    const id = c.req.param("id");
    const monthKey = `${year}-${month}`;
    const transferKey = `transfer:${monthKey}:${id}`;
    
    await kv.del(transferKey);
    
    return c.json({
      success: true,
      message: "Transfer deleted successfully"
    });
  } catch (error: any) {
    return c.json({ 
      success: false, 
      error: `Failed to delete transfer: ${error.message}` 
    }, 500);
  }
});

// ============================================
// SMART SUGGESTIONS ENDPOINTS
// ============================================

// Get smart suggestions for a month
app.get("/make-server-3adbeaf1/suggestions/:year/:month", async (c) => {
  try {
    const year = c.req.param("year");
    const month = c.req.param("month");
    const monthKey = `${year}-${month}`;
    
    const suggestions = await generateSuggestions(monthKey);
    
    // Sort by priority
    const priorityOrder = { high: 0, medium: 1, low: 2 };
    suggestions.sort((a, b) => priorityOrder[a.priority] - priorityOrder[b.priority]);
    
    return c.json({
      success: true,
      data: {
        suggestions,
        count: suggestions.length,
        byPriority: {
          high: suggestions.filter(s => s.priority === 'high').length,
          medium: suggestions.filter(s => s.priority === 'medium').length,
          low: suggestions.filter(s => s.priority === 'low').length
        }
      }
    });
  } catch (error) {
    console.log(`Error generating suggestions: ${error}`);
    return c.json({ success: false, error: error.message }, 500);
  }
});

// Get budget health score
app.get("/make-server-3adbeaf1/health/:year/:month", async (c) => {
  try {
    const year = c.req.param("year");
    const month = c.req.param("month");
    const monthKey = `${year}-${month}`;
    
    const health = await calculateBudgetHealth(monthKey);
    
    return c.json({
      success: true,
      data: health
    });
  } catch (error) {
    console.log(`Error calculating budget health: ${error}`);
    return c.json({ success: false, error: error.message }, 500);
  }
});

// ============================================
// ARCHIVE ENDPOINTS
// ============================================

// Archive a pocket (balance must be 0)
app.post("/make-server-3adbeaf1/archive/:year/:month", async (c) => {
  try {
    const year = c.req.param("year");
    const month = c.req.param("month");
    const monthKey = `${year}-${month}`;
    const body = await c.req.json();
    const { pocketId, reason } = body;
    
    if (!pocketId) {
      return c.json({ 
        success: false, 
        error: 'Missing pocketId' 
      }, 400);
    }
    
    const result = await archivePocket({
      pocketId,
      monthKey,
      reason
    });
    
    return c.json({
      success: true,
      data: result
    });
  } catch (error) {
    console.log(`Error archiving pocket: ${error}`);
    return c.json({ 
      success: false, 
      error: error.message 
    }, 400);
  }
});

// Unarchive a pocket (restore)
app.post("/make-server-3adbeaf1/unarchive/:year/:month", async (c) => {
  try {
    const year = c.req.param("year");
    const month = c.req.param("month");
    const monthKey = `${year}-${month}`;
    const body = await c.req.json();
    const { pocketId } = body;
    
    if (!pocketId) {
      return c.json({ 
        success: false, 
        error: 'Missing pocketId' 
      }, 400);
    }
    
    const result = await unarchivePocket(pocketId, monthKey);
    
    return c.json({
      success: true,
      data: result
    });
  } catch (error) {
    console.log(`Error unarchiving pocket: ${error}`);
    return c.json({ 
      success: false, 
      error: error.message 
    }, 400);
  }
});

// Get archived pockets
app.get("/make-server-3adbeaf1/archived", async (c) => {
  try {
    const archived = await getArchivedPockets();
    
    return c.json({
      success: true,
      data: {
        archived,
        count: archived.length
      }
    });
  } catch (error) {
    console.log(`Error fetching archived pockets: ${error}`);
    return c.json({ success: false, error: error.message }, 500);
  }
});

// Get archive history
app.get("/make-server-3adbeaf1/archive/history", async (c) => {
  try {
    const history = await getArchiveHistory();
    
    return c.json({
      success: true,
      data: {
        history,
        count: history.length
      }
    });
  } catch (error) {
    console.log(`Error fetching archive history: ${error}`);
    return c.json({ success: false, error: error.message }, 500);
  }
});

// ============================================
// POCKETS ENDPOINTS (Additional endpoints - main GET endpoint is above)
// ============================================

// Create custom pocket
app.post("/make-server-3adbeaf1/pockets/:year/:month", async (c) => {
  try {
    const year = c.req.param("year");
    const month = c.req.param("month");
    const monthKey = `${year}-${month}`;
    const body = await c.req.json();
    const { name, description, icon, color, enableWishlist } = body;
    
    if (!name || !name.trim()) {
      return c.json({ 
        success: false, 
        error: 'Pocket name is required' 
      }, 400);
    }
    
    // Get current pockets
    const pockets = await getPockets(monthKey);
    
    // Check if name already exists
    if (pockets.some((p: Pocket) => p.name.toLowerCase() === name.trim().toLowerCase())) {
      return c.json({ 
        success: false, 
        error: 'Pocket with this name already exists' 
      }, 400);
    }
    
    // Create new pocket
    const newPocket: Pocket = {
      id: `pocket_${Date.now()}_${crypto.randomUUID().substring(0, 8)}`,
      name: name.trim(),
      type: 'custom',
      description: description?.trim(),
      icon: icon || 'Wallet',
      color: color || 'blue',
      order: pockets.length + 1,
      createdAt: new Date().toISOString(),
      enableWishlist: enableWishlist !== undefined ? Boolean(enableWishlist) : true  // Default to true for custom pockets
    };
    
    // Add to pockets list
    pockets.push(newPocket);
    await kv.set(`pockets:${monthKey}`, pockets);
    
    return c.json({
      success: true,
      data: {
        pocket: newPocket,
        message: `Kantong "${name}" berhasil dibuat`
      }
    });
  } catch (error) {
    console.log(`Error creating pocket: ${error}`);
    return c.json({ success: false, error: error.message }, 500);
  }
});

// Edit custom pocket
app.put("/make-server-3adbeaf1/pockets/:year/:month/:pocketId", async (c) => {
  try {
    const year = c.req.param("year");
    const month = c.req.param("month");
    const pocketId = c.req.param("pocketId");
    const monthKey = `${year}-${month}`;
    const body = await c.req.json();
    const { name, description, icon, color } = body;
    
    if (!name || !name.trim()) {
      return c.json({ 
        success: false, 
        error: 'Pocket name is required' 
      }, 400);
    }
    
    // Get current pockets
    const pockets = await getPockets(monthKey);
    
    // Find pocket to edit
    const pocketIndex = pockets.findIndex((p: Pocket) => p.id === pocketId);
    if (pocketIndex === -1) {
      return c.json({ 
        success: false, 
        error: 'Pocket not found' 
      }, 404);
    }
    
    const pocket = pockets[pocketIndex];
    
    // Can't edit primary pockets
    if (pocket.type === 'primary') {
      return c.json({ 
        success: false, 
        error: 'Cannot edit primary pockets' 
      }, 400);
    }
    
    // Check if new name already exists (excluding current pocket)
    if (pockets.some((p: Pocket) => 
      p.id !== pocketId && 
      p.name.toLowerCase() === name.trim().toLowerCase()
    )) {
      return c.json({ 
        success: false, 
        error: 'Pocket with this name already exists' 
      }, 400);
    }
    
    // Update pocket
    pockets[pocketIndex] = {
      ...pocket,
      name: name.trim(),
      description: description?.trim(),
      icon: icon || pocket.icon,
      color: color || pocket.color,
    };
    
    await kv.set(`pockets:${monthKey}`, pockets);
    
    return c.json({
      success: true,
      data: {
        pocket: pockets[pocketIndex],
        message: `Kantong "${name}" berhasil diperbarui`
      }
    });
  } catch (error) {
    console.log(`Error editing pocket: ${error}`);
    return c.json({ success: false, error: error.message }, 500);
  }
});

// Delete/unarchive via DELETE method
app.delete("/make-server-3adbeaf1/archive/:pocketId/:year/:month", async (c) => {
  try {
    const year = c.req.param("year");
    const month = c.req.param("month");
    const pocketId = c.req.param("pocketId");
    const monthKey = `${year}-${month}`;
    
    if (!pocketId) {
      return c.json({ 
        success: false, 
        error: 'Missing pocketId' 
      }, 400);
    }
    
    const result = await unarchivePocket(pocketId, monthKey);
    
    return c.json({
      success: true,
      data: result,
      message: result.message
    });
  } catch (error) {
    console.log(`Error unarchiving pocket: ${error}`);
    return c.json({ 
      success: false, 
      error: error.message 
    }, 400);
  }
});

// ============================================
// WISHLIST & SIMULATION - TYPE DEFINITIONS
// ============================================

interface WishlistItem {
  id: string;
  pocketId: string;
  name: string;
  amount: number;
  priority: 1 | 2 | 3;          // 1=High, 2=Medium, 3=Low
  
  // Optional metadata
  description?: string;
  url?: string;                  // Product URL
  imageUrl?: string;             // Product image
  targetDate?: string;           // When planning to buy (ISO date)
  tags?: string[];               // ['gaming', 'electronics']
  
  // Status tracking
  status: 'planned' | 'saving' | 'ready' | 'purchased';
  purchasedAt?: string;          // ISO date
  purchasedExpenseId?: string;   // Link to expense
  
  // Metadata
  createdAt: string;
  updatedAt: string;
  notes?: string;
}

interface SimulationScenario {
  itemId: string;
  itemName: string;
  amount: number;
  currentBalance: number;
  balanceAfter: number;
  status: 'affordable' | 'low-balance' | 'insufficient';
  blockedItems: string[];        // Items that become unaffordable
  warning?: string;
}

interface SimulationResult {
  pocketId: string;
  pocketName: string;
  currentBalance: number;
  
  wishlist: {
    total: number;
    count: number;
    byPriority: {
      high: { count: number; total: number };
      medium: { count: number; total: number };
      low: { count: number; total: number };
    };
  };
  
  // Affordability analysis
  affordableNow: string[];       // Item IDs
  affordableSoon: Array<{        // Need small amount
    itemId: string;
    amountNeeded: number;
    estimatedWeeks: number;
  }>;
  notAffordable: string[];       // Item IDs
  
  // Priority-based scenarios
  scenarios: SimulationScenario[];
  
  // Recommendations
  recommendations: Array<{
    type: 'warning' | 'info' | 'suggestion';
    message: string;
    actionable: boolean;
    action?: {
      type: 'transfer' | 'save' | 'reprioritize';
      params: any;
    };
  }>;
}

interface SavingsPlan {
  itemId: string;
  itemName: string;
  targetAmount: number;
  currentAmount: number;
  amountNeeded: number;
  
  targetDate?: string;
  estimatedDate: string;         // Based on income patterns
  
  // Suggestions
  weeklyTransfer: number;
  monthlyTransfer: number;
  weeksNeeded: number;
}

// ============================================
// WISHLIST ENDPOINTS
// ============================================

// Get wishlist for a pocket
app.get("/make-server-3adbeaf1/wishlist/:year/:month/:pocketId", async (c) => {
  try {
    const year = c.req.param("year");
    const month = c.req.param("month");
    const pocketId = c.req.param("pocketId");
    const monthKey = `${year}-${month}`;
    
    const wishlist = await kv.get<WishlistItem[]>(`wishlist:${monthKey}:${pocketId}`) || [];
    
    // Filter out purchased items by default (unless query param includes them)
    const includePurchased = c.req.query('includePurchased') === 'true';
    const activeItems = includePurchased 
      ? wishlist 
      : wishlist.filter(item => item.status !== 'purchased');
    
    return c.json({
      success: true,
      data: {
        wishlist: activeItems,
        count: activeItems.length,
        total: activeItems.reduce((sum, item) => sum + item.amount, 0)
      }
    });
  } catch (error) {
    console.log(`Error fetching wishlist: ${error}`);
    return c.json({ success: false, error: error.message }, 500);
  }
});

// Add wishlist item
app.post("/make-server-3adbeaf1/wishlist/:year/:month/:pocketId", async (c) => {
  try {
    const year = c.req.param("year");
    const month = c.req.param("month");
    const pocketId = c.req.param("pocketId");
    const monthKey = `${year}-${month}`;
    const body = await c.req.json();
    
    const { name, amount, priority, description, url, imageUrl, targetDate, tags, notes } = body;
    
    if (!name || !name.trim()) {
      return c.json({ 
        success: false, 
        error: 'Item name is required' 
      }, 400);
    }
    
    if (!amount || amount <= 0) {
      return c.json({ 
        success: false, 
        error: 'Valid amount is required' 
      }, 400);
    }
    
    // Create new wishlist item
    const newItem: WishlistItem = {
      id: `wishlist_${Date.now()}_${crypto.randomUUID().substring(0, 8)}`,
      pocketId,
      name: name.trim(),
      amount: parseFloat(amount),
      priority: priority || 2, // Default to medium
      description: description?.trim(),
      url,
      imageUrl,
      targetDate,
      tags: tags || [],
      status: 'planned',
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      notes
    };
    
    // Get existing wishlist
    const wishlist = await kv.get<WishlistItem[]>(`wishlist:${monthKey}:${pocketId}`) || [];
    wishlist.push(newItem);
    await kv.set(`wishlist:${monthKey}:${pocketId}`, wishlist);
    
    return c.json({
      success: true,
      data: {
        item: newItem,
        message: `"${name}" ditambahkan ke wishlist`
      }
    });
  } catch (error) {
    console.log(`Error adding wishlist item: ${error}`);
    return c.json({ success: false, error: error.message }, 500);
  }
});

// Update wishlist item
app.put("/make-server-3adbeaf1/wishlist/:year/:month/:pocketId/:itemId", async (c) => {
  try {
    const year = c.req.param("year");
    const month = c.req.param("month");
    const pocketId = c.req.param("pocketId");
    const itemId = c.req.param("itemId");
    const monthKey = `${year}-${month}`;
    const body = await c.req.json();
    
    const wishlist = await kv.get<WishlistItem[]>(`wishlist:${monthKey}:${pocketId}`) || [];
    const itemIndex = wishlist.findIndex(item => item.id === itemId);
    
    if (itemIndex === -1) {
      return c.json({ 
        success: false, 
        error: 'Wishlist item not found' 
      }, 404);
    }
    
    // Update item
    wishlist[itemIndex] = {
      ...wishlist[itemIndex],
      ...body,
      id: itemId, // Preserve ID
      pocketId, // Preserve pocket ID
      updatedAt: new Date().toISOString()
    };
    
    await kv.set(`wishlist:${monthKey}:${pocketId}`, wishlist);
    
    return c.json({
      success: true,
      data: {
        item: wishlist[itemIndex],
        message: 'Item updated'
      }
    });
  } catch (error) {
    console.log(`Error updating wishlist item: ${error}`);
    return c.json({ success: false, error: error.message }, 500);
  }
});

// Delete wishlist item
app.delete("/make-server-3adbeaf1/wishlist/:year/:month/:pocketId/:itemId", async (c) => {
  try {
    const year = c.req.param("year");
    const month = c.req.param("month");
    const pocketId = c.req.param("pocketId");
    const itemId = c.req.param("itemId");
    const monthKey = `${year}-${month}`;
    
    const wishlist = await kv.get<WishlistItem[]>(`wishlist:${monthKey}:${pocketId}`) || [];
    const filteredWishlist = wishlist.filter(item => item.id !== itemId);
    
    if (wishlist.length === filteredWishlist.length) {
      return c.json({ 
        success: false, 
        error: 'Wishlist item not found' 
      }, 404);
    }
    
    await kv.set(`wishlist:${monthKey}:${pocketId}`, filteredWishlist);
    
    return c.json({
      success: true,
      data: {
        message: 'Item deleted'
      }
    });
  } catch (error) {
    console.log(`Error deleting wishlist item: ${error}`);
    return c.json({ success: false, error: error.message }, 500);
  }
});

// Purchase wishlist item (convert to expense)
app.post("/make-server-3adbeaf1/wishlist/:year/:month/:pocketId/:itemId/purchase", async (c) => {
  try {
    const year = c.req.param("year");
    const month = c.req.param("month");
    const pocketId = c.req.param("pocketId");
    const itemId = c.req.param("itemId");
    const monthKey = `${year}-${month}`;
    const body = await c.req.json();
    const { purchaseDate } = body;
    
    // Get wishlist item
    const wishlist = await kv.get<WishlistItem[]>(`wishlist:${monthKey}:${pocketId}`) || [];
    const itemIndex = wishlist.findIndex(item => item.id === itemId);
    
    if (itemIndex === -1) {
      return c.json({ 
        success: false, 
        error: 'Wishlist item not found' 
      }, 404);
    }
    
    const item = wishlist[itemIndex];
    
    if (item.status === 'purchased') {
      return c.json({ 
        success: false, 
        error: 'Item already purchased' 
      }, 400);
    }
    
    // Create expense
    const expense = {
      id: `expense_${Date.now()}_${crypto.randomUUID().substring(0, 8)}`,
      name: item.name,
      amount: item.amount,
      date: purchaseDate || new Date().toISOString(),
      pocketId: pocketId,
      createdAt: new Date().toISOString(),
      metadata: {
        fromWishlist: true,
        wishlistItemId: item.id,
        wishlistPriority: item.priority
      }
    };
    
    // Save expense
    const expenses = await kv.get<any[]>(`expenses:${monthKey}`) || [];
    expenses.push(expense);
    await kv.set(`expenses:${monthKey}`, expenses);
    
    // Update wishlist item status
    wishlist[itemIndex] = {
      ...item,
      status: 'purchased',
      purchasedAt: expense.date,
      purchasedExpenseId: expense.id,
      updatedAt: new Date().toISOString()
    };
    
    await kv.set(`wishlist:${monthKey}:${pocketId}`, wishlist);
    
    return c.json({
      success: true,
      data: {
        expense,
        updatedItem: wishlist[itemIndex],
        message: `"${item.name}" dibeli dan ditambahkan ke pengeluaran`
      }
    });
  } catch (error) {
    console.log(`Error purchasing wishlist item: ${error}`);
    return c.json({ success: false, error: error.message }, 500);
  }
});

// Simulate wishlist budget
app.post("/make-server-3adbeaf1/wishlist/:year/:month/:pocketId/simulate", async (c) => {
  try {
    const year = c.req.param("year");
    const month = c.req.param("month");
    const pocketId = c.req.param("pocketId");
    const monthKey = `${year}-${month}`;
    
    const simulation = await simulateWishlist(pocketId, monthKey);
    
    return c.json({
      success: true,
      data: simulation
    });
  } catch (error) {
    console.log(`Error simulating wishlist: ${error}`);
    return c.json({ success: false, error: error.message }, 500);
  }
});

// Generate savings plan
app.post("/make-server-3adbeaf1/wishlist/:year/:month/:pocketId/:itemId/savings-plan", async (c) => {
  try {
    const year = c.req.param("year");
    const month = c.req.param("month");
    const pocketId = c.req.param("pocketId");
    const itemId = c.req.param("itemId");
    const monthKey = `${year}-${month}`;
    
    const savingsPlan = await generateSavingsPlan(pocketId, itemId, monthKey);
    
    return c.json({
      success: true,
      data: savingsPlan
    });
  } catch (error) {
    console.log(`Error generating savings plan: ${error}`);
    return c.json({ success: false, error: error.message }, 500);
  }
});

// ============================================
// WISHLIST HELPER FUNCTIONS
// ============================================

/**
 * Generate simulation for pocket wishlist
 */
async function simulateWishlist(
  pocketId: string,
  monthKey: string
): Promise<SimulationResult> {
  // 1. Get current balance
  const balance = await calculatePocketBalance(pocketId, monthKey);
  const currentBalance = balance.availableBalance;
  
  // 2. Get wishlist items
  const wishlist = await kv.get<WishlistItem[]>(`wishlist:${monthKey}:${pocketId}`) || [];
  const activeItems = wishlist.filter(item => item.status !== 'purchased');
  
  // 3. Sort by priority (1=High first)
  const sortedItems = [...activeItems].sort((a, b) => a.priority - b.priority);
  
  // 4. Calculate totals
  const total = activeItems.reduce((sum, item) => sum + item.amount, 0);
  const byPriority = {
    high: {
      count: activeItems.filter(i => i.priority === 1).length,
      total: activeItems.filter(i => i.priority === 1).reduce((sum, i) => sum + i.amount, 0)
    },
    medium: {
      count: activeItems.filter(i => i.priority === 2).length,
      total: activeItems.filter(i => i.priority === 2).reduce((sum, i) => sum + i.amount, 0)
    },
    low: {
      count: activeItems.filter(i => i.priority === 3).length,
      total: activeItems.filter(i => i.priority === 3).reduce((sum, i) => sum + i.amount, 0)
    }
  };
  
  // 5. Simulate cascading purchases
  let runningBalance = currentBalance;
  const scenarios: SimulationScenario[] = [];
  const affordableNow: string[] = [];
  const affordableSoon: Array<any> = [];
  const notAffordable: string[] = [];
  
  for (const item of sortedItems) {
    const balanceAfter = runningBalance - item.amount;
    let status: SimulationScenario['status'];
    
    if (balanceAfter >= item.amount) {
      // Can buy this and still have money for next item
      status = 'affordable';
      affordableNow.push(item.id);
    } else if (balanceAfter >= 0) {
      // Can buy but will be low/zero
      if (balanceAfter < 500000) {
        status = 'low-balance';
      } else {
        status = 'affordable';
      }
      affordableNow.push(item.id);
    } else {
      // Cannot afford
      status = 'insufficient';
      
      const amountNeeded = item.amount - runningBalance;
      if (amountNeeded < 1000000) {
        // Affordable soon
        affordableSoon.push({
          itemId: item.id,
          amountNeeded,
          estimatedWeeks: Math.ceil(amountNeeded / 250000) // Assume Rp 250k/week income
        });
      } else {
        notAffordable.push(item.id);
      }
    }
    
    // Find which items would be blocked if this is purchased
    const blockedItems: string[] = [];
    if (status === 'affordable' || status === 'low-balance') {
      let tempBalance = balanceAfter;
      for (let j = sortedItems.indexOf(item) + 1; j < sortedItems.length; j++) {
        const nextItem = sortedItems[j];
        if (tempBalance < nextItem.amount) {
          blockedItems.push(nextItem.id);
        }
        tempBalance -= nextItem.amount;
      }
    }
    
    scenarios.push({
      itemId: item.id,
      itemName: item.name,
      amount: item.amount,
      currentBalance: runningBalance,
      balanceAfter,
      status,
      blockedItems,
      warning: balanceAfter < 0 
        ? `Kurang Rp ${Math.abs(balanceAfter).toLocaleString('id-ID')}`
        : balanceAfter < 500000
        ? `Sisa hanya Rp ${balanceAfter.toLocaleString('id-ID')}`
        : undefined
    });
    
    // Update running balance for next iteration
    if (status === 'affordable' || status === 'low-balance') {
      runningBalance = balanceAfter;
    }
  }
  
  // 6. Generate recommendations
  const recommendations = generateWishlistRecommendations(
    currentBalance,
    total,
    scenarios,
    affordableNow,
    affordableSoon
  );
  
  // 7. Get pocket info
  const pockets = await getPockets(monthKey);
  const pocket = pockets.find(p => p.id === pocketId);
  
  return {
    pocketId,
    pocketName: pocket?.name || 'Unknown',
    currentBalance,
    wishlist: {
      total,
      count: activeItems.length,
      byPriority
    },
    affordableNow,
    affordableSoon,
    notAffordable,
    scenarios,
    recommendations
  };
}

/**
 * Generate smart recommendations
 */
function generateWishlistRecommendations(
  currentBalance: number,
  wishlistTotal: number,
  scenarios: SimulationScenario[],
  affordableNow: string[],
  affordableSoon: Array<any>
): SimulationResult['recommendations'] {
  const recs: SimulationResult['recommendations'] = [];
  
  // Recommendation 1: Overall affordability
  if (currentBalance >= wishlistTotal) {
    recs.push({
      type: 'info',
      message: `‚úÖ Saldo cukup untuk semua items (Rp ${wishlistTotal.toLocaleString('id-ID')})`,
      actionable: false
    });
  } else {
    const shortage = wishlistTotal - currentBalance;
    recs.push({
      type: 'warning',
      message: `‚ö†ÔøΩÔøΩÔøΩ Kurang Rp ${shortage.toLocaleString('id-ID')} untuk beli semua items`,
      actionable: true,
      action: {
        type: 'save',
        params: { targetAmount: shortage }
      }
    });
  }
  
  // Recommendation 2: Priority suggestions
  if (affordableNow.length > 0 && affordableNow.length < scenarios.length) {
    recs.push({
      type: 'suggestion',
      message: `üí° Bisa beli ${affordableNow.length} item sekarang (prioritas tertinggi)`,
      actionable: true,
      action: {
        type: 'reprioritize',
        params: { affordableIds: affordableNow }
      }
    });
  }
  
  // Recommendation 3: Savings plan for "soon" items
  if (affordableSoon.length > 0) {
    const firstSoon = affordableSoon[0];
    recs.push({
      type: 'suggestion',
      message: `üí∞ Transfer Rp ${Math.ceil(firstSoon.amountNeeded / firstSoon.estimatedWeeks).toLocaleString('id-ID')}/minggu untuk beli dalam ${firstSoon.estimatedWeeks} minggu`,
      actionable: true,
      action: {
        type: 'transfer',
        params: {
          amount: Math.ceil(firstSoon.amountNeeded / firstSoon.estimatedWeeks),
          frequency: 'weekly'
        }
      }
    });
  }
  
  // Recommendation 4: Balance warning
  const firstScenario = scenarios.find(s => s.status === 'low-balance');
  if (firstScenario) {
    recs.push({
      type: 'warning',
      message: `‚ö†Ô∏è Jika beli "${firstScenario.itemName}", sisa hanya Rp ${firstScenario.balanceAfter.toLocaleString('id-ID')}`,
      actionable: false
    });
  }
  
  return recs;
}

/**
 * Generate savings plan for a specific item
 */
async function generateSavingsPlan(
  pocketId: string,
  itemId: string,
  monthKey: string
): Promise<SavingsPlan> {
  const wishlist = await kv.get<WishlistItem[]>(`wishlist:${monthKey}:${pocketId}`) || [];
  const item = wishlist.find(i => i.id === itemId);
  
  if (!item) {
    throw new Error('Wishlist item not found');
  }
  
  const balance = await calculatePocketBalance(pocketId, monthKey);
  const currentAmount = balance.availableBalance;
  const amountNeeded = Math.max(0, item.amount - currentAmount);
  
  // Calculate time needed
  const assumedWeeklyIncome = 250000; // Rp 250k/week
  const weeksNeeded = Math.ceil(amountNeeded / assumedWeeklyIncome);
  
  const targetDate = item.targetDate 
    ? new Date(item.targetDate)
    : new Date(Date.now() + weeksNeeded * 7 * 24 * 60 * 60 * 1000);
  
  const estimatedDate = new Date(Date.now() + weeksNeeded * 7 * 24 * 60 * 60 * 1000);
  
  return {
    itemId: item.id,
    itemName: item.name,
    targetAmount: item.amount,
    currentAmount,
    amountNeeded,
    targetDate: item.targetDate,
    estimatedDate: estimatedDate.toISOString(),
    weeklyTransfer: Math.ceil(amountNeeded / weeksNeeded),
    monthlyTransfer: Math.ceil(amountNeeded / (weeksNeeded / 4)),
    weeksNeeded
  };
}

// ============================================
// EXCLUDE STATE ENDPOINTS
// ============================================

// REMOVED: Duplicate exclude-state endpoints (kept at line 1786-1833)

Deno.serve(app.fetch);