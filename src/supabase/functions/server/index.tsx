import { Hono } from "npm:hono";
import { cors } from "npm:hono/cors";
import { logger } from "npm:hono/logger";
import * as kv from "./kv_store.tsx";

// ============================================
// POCKETS SYSTEM - TYPE DEFINITIONS
// ============================================

type PocketType = 'primary' | 'custom';

const POCKET_IDS = {
  DAILY: 'pocket_daily',
  COLD_MONEY: 'pocket_cold_money'
} as const;

interface Pocket {
  id: string;
  name: string;
  type: PocketType;
  description?: string;
  icon?: string;
  color?: string;
  order: number;
  createdAt: string;
  status?: 'active' | 'archived';
  archivedAt?: string;
  archivedReason?: string;
  enableWishlist?: boolean;
}

const DEFAULT_POCKETS: Pocket[] = [
  {
    id: POCKET_IDS.DAILY,
    name: 'Sehari-hari',
    type: 'primary',
    description: 'Budget untuk kebutuhan sehari-hari',
    icon: 'üí∞',
    color: '#3b82f6',
    order: 1,
    createdAt: new Date().toISOString(),
    status: 'active', // ‚úÖ FASE 1: Explicit status
    enableWishlist: false  // Daily pocket doesn't need wishlist simulation
  },
  {
    id: POCKET_IDS.COLD_MONEY,
    name: 'Uang Dingin',
    type: 'primary',
    description: 'Dana untuk hobi dan hiburan',
    icon: '‚ùÑÔ∏è',
    color: '#8b5cf6',
    order: 2,
    createdAt: new Date().toISOString(),
    status: 'active', // ‚úÖ FASE 1: Explicit status
    enableWishlist: true  // Cold money is perfect for wishlist planning
  }
];

interface PocketBalance {
  pocketId: string;
  originalAmount: number;
  income: number; // üí∞ Income for Cold Money & Custom pockets (current month)
  transferIn: number;
  transferOut: number;
  expenses: number;
  availableBalance: number; // ‚úÖ BACKWARD COMPAT: Defaults to projected balance
  realtimeBalance: number;   // ‚úÖ NEW (TUGAS 1): Balance up to today (excludes future transactions)
  projectedBalance: number;  // ‚úÖ NEW (TUGAS 1): Balance including all future transactions
  lastUpdated: string;
}

interface TransferTransaction {
  id: string;
  type: 'transfer';
  amount: number;
  fromPocketId: string;
  toPocketId: string;
  fromPocketName?: string; // Stored for history preservation (added for backward compatibility)
  toPocketName?: string;   // Stored for history preservation (added for backward compatibility)
  date: string;
  note?: string;
  createdAt: string;
}

type TransactionType = 'income' | 'expense' | 'transfer' | 'initial_balance'; // ‚úÖ FASE 3: Added initial_balance

interface TimelineEntry {
  id: string;
  type: TransactionType;
  date: string;
  description: string;
  amount: number;
  balanceAfter: number;
  icon: string;
  color: string;
  metadata?: any;
}

// ============================================
// SMART SUGGESTIONS - TYPE DEFINITIONS
// ============================================

/**
 * Suggestion Types
 */
type SuggestionType = 
  | 'transfer'        // Suggest moving money
  | 'save'           // Suggest saving
  | 'reduce'         // Reduce spending
  | 'archive'        // Archive empty pocket
  | 'warning'        // Budget warning
  | 'info';          // Informational

/**
 * Suggestion
 */
interface Suggestion {
  id: string;
  type: SuggestionType;
  title: string;
  message: string;
  priority: 'high' | 'medium' | 'low';
  actionable: boolean;
  action?: {
    label: string;
    endpoint?: string;
    params?: any;
  };
  metadata?: any;
}

/**
 * Budget Health Status
 */
interface BudgetHealth {
  status: 'healthy' | 'warning' | 'critical';
  score: number;  // 0-100
  issues: string[];
  strengths: string[];
}

// ============================================
// ARCHIVE SYSTEM - TYPE DEFINITIONS
// ============================================

/**
 * Archive Request
 */
interface ArchiveRequest {
  pocketId: string;
  monthKey: string;
  reason?: string;
}

/**
 * Archive Result
 */
interface ArchiveResult {
  success: boolean;
  archivedPocket: Pocket;
  message: string;
}

/**
 * Archive History Entry
 */
interface ArchiveHistoryEntry {
  pocketId: string;
  pocketName: string;
  archivedAt: string;
  reason: string;
  balanceAtArchive: number;
}

// ============================================
// CARRY OVER SYSTEM - TYPE DEFINITIONS
// ============================================

/**
 * Carry Over Entry
 * Represents balance carried from previous month
 */
interface CarryOverEntry {
  id: string;
  pocketId: string;
  fromMonth: string;        // '2025-10'
  toMonth: string;          // '2025-11'
  amount: number;           // Total carried over
  
  breakdown: {
    originalBalance: number;    // Starting balance bulan lalu
    income: number;            // Total income bulan lalu
    expenses: number;          // Total expenses bulan lalu
    transferIn: number;        // Total transfer masuk bulan lalu
    transferOut: number;       // Total transfer keluar bulan lalu
    finalBalance: number;      // = amount (for verification)
  };
  
  createdAt: string;        // ISO date
  autoGenerated: boolean;   // true = auto, false = manual
}

/**
 * Carry Over Summary (for display)
 */
interface CarryOverSummary {
  monthKey: string;
  pockets: Array<{
    pocketId: string;
    pocketName: string;
    carryOverAmount: number;
    hasCarryOver: boolean;
    fromMonth: string;
  }>;
  totalCarryOver: number;
}

// ============================================
// POCKETS SYSTEM - HELPER FUNCTIONS
// ============================================

// ============================================
// üöÄ FASE 1: GLOBAL POCKET REGISTRY
// New approach: Pockets are permanent entities (global storage)
// ============================================

/**
 * Get all pockets from GLOBAL registry (not month-specific)
 * ‚úÖ NEW APPROACH: Pockets are permanent entities
 * 
 * @returns Array of all active pockets
 */
async function getGlobalPockets(): Promise<Pocket[]> {
  try {
    const pockets = await kv.getByPrefix('pocket:global:');
    
    if (pockets.length === 0) {
      // First time setup: Initialize default pockets
      console.log('[GLOBAL POCKETS] First time setup - initializing default pockets');
      await initializeDefaultPockets();
      return DEFAULT_POCKETS;
    }
    
    // Sort by order
    return pockets.sort((a: Pocket, b: Pocket) => a.order - b.order);
  } catch (error) {
    console.error('[GLOBAL POCKETS] Error fetching pockets:', error);
    return DEFAULT_POCKETS;
  }
}

/**
 * Initialize default pockets in global registry
 * Called on first time setup
 */
async function initializeDefaultPockets(): Promise<void> {
  const promises = DEFAULT_POCKETS.map(pocket => 
    kv.set(`pocket:global:${pocket.id}`, pocket)
  );
  await Promise.all(promises);
  console.log('[GLOBAL POCKETS] Default pockets initialized:', DEFAULT_POCKETS.map(p => p.name).join(', '));
}

/**
 * Create a new pocket in GLOBAL registry
 * 
 * @param pocket - Pocket object to create
 * @returns Created pocket
 */
async function createGlobalPocket(pocket: Pocket): Promise<Pocket> {
  await kv.set(`pocket:global:${pocket.id}`, pocket);
  console.log(`[GLOBAL POCKETS] Created pocket: ${pocket.name} (${pocket.id})`);
  return pocket;
}

/**
 * Update a pocket in GLOBAL registry
 * 
 * @param pocketId - ID of pocket to update
 * @param updates - Partial pocket object with updates
 * @returns Updated pocket
 */
async function updateGlobalPocket(
  pocketId: string, 
  updates: Partial<Pocket>
): Promise<Pocket> {
  const existing = await kv.get(`pocket:global:${pocketId}`);
  if (!existing) {
    throw new Error(`Pocket ${pocketId} not found`);
  }
  
  const updated = { ...existing, ...updates };
  await kv.set(`pocket:global:${pocketId}`, updated);
  console.log(`[GLOBAL POCKETS] Updated pocket: ${pocketId}`, Object.keys(updates));
  return updated;
}

/**
 * Delete pocket (soft delete - archive)
 * Pockets are NEVER truly deleted, only archived
 * 
 * @param pocketId - ID of pocket to archive
 */
async function archivePocket(pocketId: string): Promise<void> {
  await updateGlobalPocket(pocketId, {
    status: 'archived',
    archivedAt: new Date().toISOString()
  });
  console.log(`[GLOBAL POCKETS] Archived pocket: ${pocketId}`);
}

/**
 * Get active pockets only (exclude archived)
 * 
 * @returns Array of active pockets
 */
async function getActivePockets(): Promise<Pocket[]> {
  const allPockets = await getGlobalPockets();
  return allPockets.filter(p => p.status !== 'archived');
}

// ============================================
// üîß BACKWARD COMPATIBILITY: Old getPockets() function
// Kept for migration period, will be removed in Phase 2
// ============================================

/**
 * Get or create pockets for a month
 * Includes auto-migration for legacy icon names
 * 
 * ‚ö†Ô∏è UPDATED: Now fetches from global registry
 * Month parameter kept for API compatibility
 */
async function getPockets(monthKey: string): Promise<Pocket[]> {
  // ‚úÖ FASE 1: Now fetch from global registry (not per-month)
  // Month parameter kept for backward compatibility with API
  return await getActivePockets();
}

/**
 * Calculate balance for a specific pocket
 * @param sharedData - Optional shared data to avoid redundant fetches
 * @param asOfDate - Optional date to calculate balance as of specific date (for realtime mode)
 * 
 * üî• UNIVERSAL CARRY-OVER V4: Now returns both realtime and projected balances
 */
async function calculatePocketBalance(
  pocketId: string,
  monthKey: string,
  sharedData?: {
    budget?: any;
    expensesData?: any[];
    additionalIncome?: any[];
    transfers?: any[];
    excludeState?: any;
  },
  asOfDate?: string  // ‚úÖ NEW: Optional date for realtime calculation (ISO format)
): Promise<PocketBalance> {
  // Get all data (use shared data if provided)
  // ‚úÖ BACKWARD COMPATIBILITY: carryover field removed, default to 0 for old data
  let budget, expensesData, additionalIncome, transfers, excludeState;
  
  if (sharedData) {
    budget = sharedData.budget;
    expensesData = sharedData.expensesData;
    additionalIncome = sharedData.additionalIncome;
    transfers = sharedData.transfers;
    excludeState = sharedData.excludeState;
  } else {
    try {
      budget = await kv.get(`budget:${monthKey}`).catch(() => null);
      expensesData = await kv.getByPrefix(`expense:${monthKey}:`).catch(() => []);
      additionalIncome = await kv.getByPrefix(`income:${monthKey}:`).catch(() => []);
      transfers = await kv.getByPrefix(`transfer:${monthKey}:`).catch(() => []);
      excludeState = await kv.get(`exclude-state:${monthKey}`).catch(() => null);
    } catch (error: any) {
      console.warn(`[BALANCE] Failed to fetch data for ${monthKey}:`, error.message);
      budget = null;
      expensesData = [];
      additionalIncome = [];
      transfers = [];
      excludeState = null;
    }
  }
  
  budget = budget || { initialBudget: 0 };
  expensesData = expensesData || [];
  additionalIncome = additionalIncome || [];
  transfers = transfers || [];
  excludeState = excludeState || { excludedExpenseIds: [], excludedIncomeIds: [] };
  
  const excludedExpenseIds = new Set(excludeState.excludedExpenseIds || []);
  const excludedIncomeIds = new Set(excludeState.excludedIncomeIds || []);
  
  // ‚úÖ TUGAS 1: Date filtering for realtime vs projected
  // When asOfDate is provided: filter transactions up to that date (REALTIME)
  // When asOfDate is NOT provided: include ALL transactions (PROJECTED)
  const cutoffDate = asOfDate ? new Date(asOfDate) : null;
  if (cutoffDate) {
    cutoffDate.setHours(23, 59, 59, 999); // End of day
  }
  const cutoffTime = cutoffDate ? cutoffDate.getTime() : null;
  
  // üîç DEBUG: List all expenses for this pocket to see if there are future transactions
  const pocketExpenses = expensesData.filter((e: any) => e.pocketId === pocketId && !excludedExpenseIds.has(e.id));
  
  console.log(`[BALANCE] üîç Date Filter for ${pocketId}:`, {
    asOfDate,
    cutoffDate: cutoffDate ? cutoffDate.toISOString() : 'NO_CUTOFF (projected mode)',
    mode: cutoffDate ? 'REALTIME' : 'PROJECTED',
    totalExpensesForPocket: pocketExpenses.length,
    expenseDates: pocketExpenses.map((e: any) => e.date).sort()
  });
  
  const isOnOrBefore = (dateStr: string): boolean => {
    // If no cutoff (projected mode), include all transactions
    if (!cutoffTime) return true;
    
    // Otherwise, check if date is on or before cutoff
    const date = new Date(dateStr);
    date.setHours(0, 0, 0, 0);
    return date.getTime() <= cutoffTime;
  };
  
  let originalAmount = 0;
  let transferIn = 0;
  let transferOut = 0;
  let expensesTotal = 0;
  
  // ============================================
  // üöÄ FASE 2: PROPER CARRY-OVER LOGIC PER POCKET TYPE
  // ============================================
  
  // Calculate original amount for this month
  if (pocketId === POCKET_IDS.DAILY) {
    // ‚úÖ TIPE 1: SEHARI-HARI (Zero-Based Budgeting)
    // Saldo Awal = Carry-over bulan lalu + Budget baru bulan ini
    const carryOver = await getCarryOverForPocket(pocketId, monthKey);
    const newBudget = budget?.initialBudget || 0;
    
    originalAmount = (carryOver?.amount || 0) + newBudget;
    
    console.log(`[BALANCE] üí∞ Daily Pocket ${monthKey}:`, {
      carryOverFromPrevMonth: carryOver?.amount || 0,
      newMonthBudget: newBudget,
      totalSaldoAwal: originalAmount
    });
    
  } else if (pocketId === POCKET_IDS.COLD_MONEY) {
    // ‚úÖ TIPE 2: UANG DINGIN (Simple Carry-Over)
    // Saldo Awal = Saldo akhir bulan lalu
    // Income bulan ini ditambahkan TERPISAH (bukan di saldo awal)
    const carryOver = await getCarryOverForPocket(pocketId, monthKey);
    
    originalAmount = carryOver?.amount || 0;
    
    console.log(`[BALANCE] ‚ùÑÔ∏è Cold Money ${monthKey}:`, {
      carryOverFromPrevMonth: carryOver?.amount || 0,
      totalSaldoAwal: originalAmount
    });
    
  } else {
    // ‚úÖ TIPE 3: CUSTOM POCKETS (Simple Carry-Over)
    // Saldo Awal = Saldo akhir bulan lalu
    const carryOver = await getCarryOverForPocket(pocketId, monthKey);
    
    originalAmount = carryOver?.amount || 0;
    
    console.log(`[BALANCE] üéØ Custom Pocket ${monthKey}:`, {
      pocketId,
      carryOverFromPrevMonth: carryOver?.amount || 0,
      totalSaldoAwal: originalAmount
    });
  }
  
  // ============================================
  // ‚úÖ TUGAS 1: CALCULATE REALTIME BALANCE (up to cutoff date)
  // ============================================
  
  // Calculate transfers (REALTIME - up to cutoff date)
  const transferInRealtime = transfers
    .filter((t: TransferTransaction) => t.toPocketId === pocketId && isOnOrBefore(t.date))
    .reduce((sum: number, t: TransferTransaction) => sum + t.amount, 0);
    
  const transferOutRealtime = transfers
    .filter((t: TransferTransaction) => t.fromPocketId === pocketId && isOnOrBefore(t.date))
    .reduce((sum: number, t: TransferTransaction) => sum + t.amount, 0);
  
  // Calculate expenses for this pocket (REALTIME - up to cutoff date)
  const realtimeExpenses = expensesData
    .filter((e: any) => e.pocketId === pocketId && !excludedExpenseIds.has(e.id) && isOnOrBefore(e.date));
  const expensesTotalRealtime = realtimeExpenses
    .reduce((sum: number, e: any) => sum + e.amount, 0);
  
  console.log(`[BALANCE] üí∏ Realtime Expenses for ${pocketId}:`, {
    count: realtimeExpenses.length,
    total: expensesTotalRealtime,
    dates: realtimeExpenses.map((e: any) => e.date).slice(0, 3)
  });
  
  // ‚úÖ FASE 2: Add income for Uang Dingin and Custom Pockets (REALTIME - up to cutoff date)
  let incomeTotalRealtime = 0;
  if (pocketId === POCKET_IDS.COLD_MONEY || pocketId.startsWith('pocket_custom_')) {
    // ‚úÖ FIX: Handle cases where amountIDR might be missing (backward compat)
    // ‚úÖ BACKWARD COMPATIBILITY: If income.pocketId is undefined, default to COLD_MONEY
    incomeTotalRealtime = additionalIncome
      .filter((income: any) => {
        const incomePocketId = income.pocketId || POCKET_IDS.COLD_MONEY;
        return incomePocketId === pocketId && 
               !excludedIncomeIds.has(income.id) &&
               isOnOrBefore(income.date);
      })
      .reduce((sum: number, income: any) => {
        const incomeAmount = income.amountIDR || income.amount || 0;
        const deduction = income.deduction || 0;
        return sum + (incomeAmount - deduction);
      }, 0);
  }
  
  const realtimeBalance = originalAmount + incomeTotalRealtime + transferInRealtime - transferOutRealtime - expensesTotalRealtime;
  
  // ============================================
  // ‚úÖ TUGAS 1: CALCULATE PROJECTED BALANCE (all transactions)
  // ============================================
  
  // Calculate transfers (PROJECTED - all transactions)
  const transferInProjected = transfers
    .filter((t: TransferTransaction) => t.toPocketId === pocketId)
    .reduce((sum: number, t: TransferTransaction) => sum + t.amount, 0);
    
  const transferOutProjected = transfers
    .filter((t: TransferTransaction) => t.fromPocketId === pocketId)
    .reduce((sum: number, t: TransferTransaction) => sum + t.amount, 0);
  
  // Calculate expenses for this pocket (PROJECTED - all transactions)
  const projectedExpenses = expensesData
    .filter((e: any) => e.pocketId === pocketId && !excludedExpenseIds.has(e.id));
  const expensesTotalProjected = projectedExpenses
    .reduce((sum: number, e: any) => sum + e.amount, 0);
  
  console.log(`[BALANCE] üí∏ Projected Expenses for ${pocketId}:`, {
    count: projectedExpenses.length,
    total: expensesTotalProjected,
    dates: projectedExpenses.map((e: any) => e.date).slice(0, 3)
  });
  
  // ‚úÖ FASE 2: Add income for Uang Dingin and Custom Pockets (PROJECTED - all transactions)
  let incomeTotalProjected = 0;
  if (pocketId === POCKET_IDS.COLD_MONEY || pocketId.startsWith('pocket_custom_')) {
    // ‚úÖ BACKWARD COMPATIBILITY: If income.pocketId is undefined, default to COLD_MONEY
    const filteredIncome = additionalIncome.filter((income: any) => {
      const incomePocketId = income.pocketId || POCKET_IDS.COLD_MONEY;
      return incomePocketId === pocketId && !excludedIncomeIds.has(income.id);
    });
    
    console.log(`[BALANCE DEBUG] ${pocketId} Income Count: ${filteredIncome.length}`);
    filteredIncome.forEach((inc: any) => {
      console.log(`[BALANCE DEBUG] Income:`, {
        id: inc.id,
        name: inc.name,
        pocketId: inc.pocketId,
        amount: inc.amount,
        amountIDR: inc.amountIDR,
        deduction: inc.deduction,
        calculated: (inc.amountIDR || inc.amount || 0) - (inc.deduction || 0)
      });
    });
    
    // ‚úÖ FIX: Handle cases where amountIDR might be missing (backward compat)
    incomeTotalProjected = filteredIncome
      .reduce((sum: number, income: any) => {
        const incomeAmount = income.amountIDR || income.amount || 0;
        const deduction = income.deduction || 0;
        return sum + (incomeAmount - deduction);
      }, 0);
    
    console.log(`[BALANCE DEBUG] Total Income Projected: ${incomeTotalProjected}`);
  }
  
  const projectedBalance = originalAmount + incomeTotalProjected + transferInProjected - transferOutProjected - expensesTotalProjected;
  
  console.log(`[BALANCE] üìä ${pocketId} ${monthKey}:`, {
    realtime: realtimeBalance,
    projected: projectedBalance,
    cutoffDate: cutoffDate ? cutoffDate.toISOString().split('T')[0] : 'NO_CUTOFF (all transactions)',
    breakdown: {
      originalAmount,
      incomeRealtime: incomeTotalRealtime,
      incomeProjected: incomeTotalProjected,
      transferInRealtime,
      transferInProjected,
      transferOutRealtime,
      transferOutProjected,
      expensesRealtime: expensesTotalRealtime,
      expensesProjected: expensesTotalProjected
    }
  });
  
  // üö® WARNING: If realtime === projected, there might be no future transactions
  if (realtimeBalance === projectedBalance && cutoffDate) {
    console.log(`[BALANCE] ‚ö†Ô∏è WARNING: Realtime and Projected are SAME for ${pocketId}!`, {
      reason: 'Likely no future transactions exist',
      realtimeExpensesCount: realtimeExpenses.length,
      projectedExpensesCount: projectedExpenses.length,
      difference: projectedExpenses.length - realtimeExpenses.length
    });
  }
  
  // ‚úÖ TUGAS 1: Return both realtime and projected balances
  return {
    pocketId,
    originalAmount,
    income: incomeTotalProjected, // üí∞ Include income in response for breakdown display (use projected for compatibility)
    transferIn: transferInProjected,
    transferOut: transferOutProjected,
    expenses: expensesTotalProjected,
    availableBalance: projectedBalance, // ‚úÖ BACKWARD COMPAT: Default to projected (end of month balance)
    realtimeBalance,  // ‚úÖ NEW: Realtime balance (up to cutoff date)
    projectedBalance, // ‚úÖ NEW: Projected balance (all transactions)
    lastUpdated: new Date().toISOString()
  };
}

// ============================================
// CARRY OVER SYSTEM - HELPER FUNCTIONS
// ============================================

/**
 * Get previous month key
 */
function getPreviousMonth(monthKey: string): string {
  const [year, month] = monthKey.split('-').map(Number);
  if (month === 1) {
    return `${year - 1}-12`;
  }
  return `${year}-${String(month - 1).padStart(2, '0')}`;
}

/**
 * Format month for display
 */
function formatMonth(monthKey: string): string {
  const [year, month] = monthKey.split('-');
  const months = ['Januari', 'Februari', 'Maret', 'April', 'Mei', 'Juni', 'Juli', 'Agustus', 'September', 'Oktober', 'November', 'Desember'];
  return `${months[parseInt(month) - 1]} ${year}`;
}

// ============================================
// üöÄ FASE 2: CARRY-OVER LOGIC
// Proper carry-over calculations per pocket type
// ============================================

/**
 * Get carry-over entry for a specific pocket
 * Helper function to fetch carry-over data
 * 
 * @param pocketId - ID of pocket
 * @param monthKey - Target month (e.g., "2025-12")
 * @returns CarryOverEntry or null if not found
 */
async function getCarryOverForPocket(
  pocketId: string,
  monthKey: string
): Promise<CarryOverEntry | null> {
  try {
    const carryOver = await kv.get(`carryover:${monthKey}:${pocketId}`);
    return carryOver;
  } catch (error) {
    console.error(`[CARRY-OVER] Error fetching for ${pocketId}:`, error);
    return null;
  }
}

/**
 * Check if carry-over data exists for a month
 * Used to determine if we need to auto-generate
 * 
 * @param monthKey - Month to check (e.g., "2025-12")
 * @returns true if carry-over data exists
 */
async function checkCarryOverExists(monthKey: string): Promise<boolean> {
  const carryOvers = await kv.getByPrefix(`carryover:${monthKey}:`);
  return carryOvers.length > 0;
}

/**
 * Generate carry-over entries for next month
 * Called automatically when user navigates to new month
 * 
 * @param currentMonthKey - Current month (e.g., "2025-11")
 */
async function generateCarryOversForNextMonth(
  currentMonthKey: string
): Promise<void> {
  try {
    // Parse current month
    const [year, month] = currentMonthKey.split('-').map(Number);
    
    // Calculate next month
    let nextYear = year;
    let nextMonth = month + 1;
    
    if (nextMonth > 12) {
      nextMonth = 1;
      nextYear = year + 1;
    }
    
    const nextMonthKey = `${nextYear}-${String(nextMonth).padStart(2, '0')}`;
    
    console.log(`[CARRY-OVER] Generating carry-overs: ${currentMonthKey} ‚Üí ${nextMonthKey}`);
    
    // Get all active pockets
    const pockets = await getActivePockets();
    
    // Generate carry-over for each pocket
    const carryOverPromises = pockets.map(async (pocket) => {
      try {
        // Calculate final balance of current month
        const balance = await calculatePocketBalance(pocket.id, currentMonthKey);
        
        // ‚úÖ TUGAS 1 FIX: Use projectedBalance (includes ALL future transactions)
        // This ensures carry-over amount matches "Saldo Proyeksi" shown in previous month
        const carryOverAmount = balance.projectedBalance ?? balance.availableBalance;
        
        // Create carry-over entry
        const carryOver: CarryOverEntry = {
          id: `carryover_${nextMonthKey}_${pocket.id}`,
          pocketId: pocket.id,
          fromMonth: currentMonthKey,
          toMonth: nextMonthKey,
          amount: carryOverAmount,
          breakdown: {
            originalBalance: balance.originalAmount,
            income: balance.income || 0, // ‚úÖ Include income from previous month
            expenses: balance.expenses,
            transferIn: balance.transferIn,
            transferOut: balance.transferOut,
            finalBalance: carryOverAmount
          },
          createdAt: new Date().toISOString(),
          autoGenerated: true
        };
        
        // Save carry-over
        await kv.set(`carryover:${nextMonthKey}:${pocket.id}`, carryOver);
        
        console.log(`[CARRY-OVER] ‚úÖ Saved: ${pocket.name} (${pocket.id}) = ${carryOver.amount}`);
        
        return carryOver;
      } catch (error) {
        console.error(`[CARRY-OVER] ‚ùå Error for pocket ${pocket.id}:`, error);
        return null;
      }
    });
    
    const results = await Promise.all(carryOverPromises);
    const successful = results.filter(r => r !== null).length;
    
    console.log(`[CARRY-OVER] üéâ Generated ${successful}/${pockets.length} carry-overs for ${nextMonthKey}`);
  } catch (error) {
    console.error('[CARRY-OVER] ‚ùå Error generating carry-overs:', error);
    throw error;
  }
}

/**
 * ‚ö†Ô∏è DEPRECATED - Use generateCarryOversForNextMonth() instead (FASE 2)
 * 
 * OLD: Stores as array at `carryovers:${toMonth}` (plural)
 * NEW: Stores per pocket at `carryover:${toMonth}:${pocketId}` (singular)
 * 
 * Kept for backward compatibility reference only.
 */
async function generateCarryOvers_DEPRECATED(
  fromMonth: string,
  toMonth: string
): Promise<CarryOverEntry[]> {
  console.warn('[DEPRECATED] generateCarryOvers() called - use generateCarryOversForNextMonth() instead');
  
  // Get all pockets from previous month
  const pockets = await getPockets(fromMonth);
  const carryOvers: CarryOverEntry[] = [];
  
  for (const pocket of pockets) {
    // Calculate final balance of previous month
    const balance = await calculatePocketBalance(pocket.id, fromMonth);
    
    // ‚úÖ TUGAS 1 FIX: Use projectedBalance for carry-over
    const carryOverAmount = balance.projectedBalance ?? balance.availableBalance;
    
    // Create carry over even if balance is 0 or negative (for tracking)
    const carryOver: CarryOverEntry = {
      id: `carryover_${toMonth}_${pocket.id}`,
      pocketId: pocket.id,
      fromMonth,
      toMonth,
      amount: carryOverAmount,
      breakdown: {
        originalBalance: balance.originalAmount,
        income: balance.income || 0, // ‚úÖ Include income from previous month
        expenses: balance.expenses,
        transferIn: balance.transferIn,
        transferOut: balance.transferOut,
        finalBalance: carryOverAmount  // ‚úÖ Use projected balance
      },
      createdAt: new Date().toISOString(),
      autoGenerated: true
    };
    
    carryOvers.push(carryOver);
  }
  
  // Save to KV store (OLD format)
  await kv.set(`carryovers:${toMonth}`, carryOvers);
  
  return carryOvers;
}

/**
 * Get or generate carry overs for a month
 */
async function getCarryOvers(monthKey: string): Promise<CarryOverEntry[]> {
  // Check if already exists
  let carryOvers = await kv.get(`carryovers:${monthKey}`);
  
  if (!carryOvers || carryOvers.length === 0) {
    // Auto-generate from previous month
    const prevMonth = getPreviousMonth(monthKey);
    
    // Check if previous month has data (check if budget exists)
    const prevBudgetKey = `budget:${prevMonth}`;
    const prevBudget = await kv.get(prevBudgetKey);
    
    // Only generate if previous month has data
    if (prevBudget || prevMonth) {
      // Check if previous month has any pockets
      const prevPockets = await kv.get(`pockets:${prevMonth}`);
      if (prevPockets && prevPockets.length > 0) {
        carryOvers = await generateCarryOvers(prevMonth, monthKey);
      } else {
        carryOvers = [];
      }
    } else {
      carryOvers = [];
    }
  }
  
  return carryOvers || [];
}

// ============================================
// SMART SUGGESTIONS - HELPER FUNCTIONS
// ============================================

/**
 * Generate smart suggestions for a month
 */
async function generateSuggestions(monthKey: string): Promise<Suggestion[]> {
  const suggestions: Suggestion[] = [];
  
  // Get all data
  const pockets = await getPockets(monthKey);
  const budgetKey = `budget:${monthKey}`;
  const budget = await kv.get(budgetKey) || { initialBudget: 0 };
  
  // Calculate balances for all pockets
  const balances = await Promise.all(
    pockets.map(async (p: Pocket) => ({
      pocket: p,
      balance: await calculatePocketBalance(p.id, monthKey)
    }))
  );
  
  // 1. Suggest transfer from high balance to low balance
  const highBalance = balances.filter(b => b.balance.availableBalance > 1000000);
  const lowBalance = balances.filter(b => b.balance.availableBalance < 100000 && b.balance.availableBalance > 0);
  
  if (highBalance.length > 0 && lowBalance.length > 0) {
    suggestions.push({
      id: `suggest_transfer_${Date.now()}`,
      type: 'transfer',
      title: 'Transfer Antar Kantong',
      message: `${highBalance[0].pocket.name} punya saldo tinggi (Rp ${highBalance[0].balance.availableBalance.toLocaleString('id-ID')}). Pertimbangkan transfer ke ${lowBalance[0].pocket.name}?`,
      priority: 'medium',
      actionable: true,
      action: {
        label: 'Transfer Sekarang',
        endpoint: '/transfer',
        params: {
          fromPocketId: highBalance[0].pocket.id,
          toPocketId: lowBalance[0].pocket.id,
          suggestedAmount: Math.min(500000, Math.floor(highBalance[0].balance.availableBalance * 0.2))
        }
      }
    });
  }
  
  // 2. Suggest archiving empty custom pockets
  const emptyCustomPockets = balances.filter(
    b => b.balance.availableBalance === 0 && 
    b.pocket.type === 'custom' &&
    b.pocket.status !== 'archived'
  );
  
  if (emptyCustomPockets.length > 0) {
    suggestions.push({
      id: `suggest_archive_${Date.now()}`,
      type: 'archive',
      title: 'Archive Kantong Kosong',
      message: `${emptyCustomPockets.length} kantong custom kosong. Archive untuk merapikan daftar?`,
      priority: 'low',
      actionable: true,
      action: {
        label: 'Lihat Kantong',
        params: { pocketIds: emptyCustomPockets.map(b => b.pocket.id) }
      }
    });
  }
  
  // 3. Budget health warning
  const totalBalance = balances.reduce((sum, b) => sum + b.balance.availableBalance, 0);
  const totalBudget = budget.initialBudget || 0;
  
  if (totalBudget > 0) {
    const remainingPercentage = (totalBalance / totalBudget) * 100;
    
    if (remainingPercentage < 20) {
      suggestions.push({
        id: `warn_low_budget_${Date.now()}`,
        type: 'warning',
        title: 'Saldo Menipis',
        message: `Sisa ${remainingPercentage.toFixed(0)}% dari budget awal. Pertimbangkan untuk mengurangi pengeluaran.`,
        priority: 'high',
        actionable: false
      });
    }
  }
  
  // 4. Negative balance warning
  const negativeBalance = balances.filter(b => b.balance.availableBalance < 0);
  
  if (negativeBalance.length > 0) {
    suggestions.push({
      id: `warn_negative_${Date.now()}`,
      type: 'warning',
      title: 'Kantong Defisit',
      message: `${negativeBalance.length} kantong defisit (saldo negatif). Segera tambah dana atau kurangi pengeluaran!`,
      priority: 'high',
      actionable: true,
      action: {
        label: 'Lihat Detail',
        params: { pocketIds: negativeBalance.map(b => b.pocket.id) }
      },
      metadata: {
        totalDeficit: negativeBalance.reduce((sum, b) => sum + Math.abs(b.balance.availableBalance), 0)
      }
    });
  }
  
  // 5. Info: Healthy budget
  if (totalBudget > 0 && totalBalance / totalBudget > 0.5 && negativeBalance.length === 0) {
    suggestions.push({
      id: `info_healthy_${Date.now()}`,
      type: 'info',
      title: 'Budget Sehat',
      message: `Budget masih ${((totalBalance / totalBudget) * 100).toFixed(0)}% tersisa. Pengeluaran terkendali! üëç`,
      priority: 'low',
      actionable: false
    });
  }
  
  return suggestions;
}

/**
 * Calculate budget health score
 */
async function calculateBudgetHealth(monthKey: string): Promise<BudgetHealth> {
  const pockets = await getPockets(monthKey);
  const budgetKey = `budget:${monthKey}`;
  const budget = await kv.get(budgetKey) || { initialBudget: 0 };
  
  // Calculate balances
  const balances = await Promise.all(
    pockets.map(async (p: Pocket) => await calculatePocketBalance(p.id, monthKey))
  );
  
  const totalBalance = balances.reduce((sum, b) => sum + b.availableBalance, 0);
  const totalBudget = budget.initialBudget || 1;
  const totalExpenses = balances.reduce((sum, b) => sum + b.expenses, 0);
  
  let score = 100;
  const issues: string[] = [];
  const strengths: string[] = [];
  
  // Check 1: Balance remaining
  const remainingPercentage = (totalBalance / totalBudget) * 100;
  if (remainingPercentage < 10) {
    score -= 30;
    issues.push('Saldo sangat tipis (< 10%)');
  } else if (remainingPercentage < 30) {
    score -= 15;
    issues.push('Saldo menipis (< 30%)');
  } else if (remainingPercentage > 50) {
    strengths.push('Saldo masih aman (> 50%)');
  }
  
  // Check 2: Negative balance pockets
  const negativeCount = balances.filter(b => b.availableBalance < 0).length;
  if (negativeCount > 0) {
    score -= negativeCount * 20;
    issues.push(`${negativeCount} kantong defisit`);
  } else {
    strengths.push('Tidak ada kantong defisit');
  }
  
  // Check 3: Spending rate
  const spendingRate = totalExpenses / totalBudget;
  if (spendingRate > 0.8) {
    score -= 20;
    issues.push('Pengeluaran tinggi (> 80% budget)');
  } else if (spendingRate < 0.5) {
    strengths.push('Pengeluaran terkendali (< 50% budget)');
  }
  
  // Determine status
  let status: BudgetHealth['status'] = 'healthy';
  if (score < 40) {
    status = 'critical';
  } else if (score < 70) {
    status = 'warning';
  }
  
  return {
    status,
    score: Math.max(0, Math.min(100, score)),
    issues,
    strengths
  };
}

// ============================================
// TIMELINE SYSTEM - HELPER FUNCTIONS
// ============================================

/**
 * Generate timeline entries for a pocket
 * Includes: initial balance, income, expenses, and transfers
 * 
 * ‚úÖ FASE 3: Updated to filter by month and use proper carry-over data
 */
async function generatePocketTimeline(
  pocketId: string,
  monthKey: string,
  sortOrder: 'asc' | 'desc',
  sharedData: any
): Promise<TimelineEntry[]> {
  const { budget, expenses, additionalIncome, transfers, excludeState, pockets } = sharedData;
  
  const excludedExpenseIds = new Set(excludeState.excludedExpenseIds || []);
  const excludedIncomeIds = new Set(excludeState.excludedIncomeIds || []);
  
  // Get pocket info
  const pocket = pockets.find((p: Pocket) => p.id === pocketId);
  const pocketName = pocket?.name || 'Unknown Pocket';
  
  // ‚úÖ FASE 3: Filter transactions by month
  const [targetYear, targetMonth] = monthKey.split('-');
  
  const isInCurrentMonth = (dateStr: string): boolean => {
    const date = new Date(dateStr);
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    return `${year}-${month}` === monthKey;
  };
  
  // Simple approach: collect all transactions, then sort and calculate balance
  const allTransactions: any[] = [];
  
  // ============================================
  // ‚úÖ FASE 3: SALDO AWAL ENTRY (Top of Timeline)
  // ============================================
  
  // 1. Add "Saldo Awal" entry for ALL pocket types
  if (pocketId === POCKET_IDS.DAILY) {
    // ‚úÖ TIPE 1: SEHARI-HARI (Zero-Based Budgeting)
    // Saldo Awal = Carry-over + Budget Baru
    let carryOver = null;
    try {
      carryOver = await getCarryOverForPocket(pocketId, monthKey);
    } catch (error) {
      console.warn('[TIMELINE] Error fetching carry-over for Daily pocket:', error);
    }
    const newBudget = budget?.initialBudget || 0;
    const totalSaldoAwal = (carryOver?.amount || 0) + newBudget;
    
    allTransactions.push({
      id: `initial_${pocketId}`,
      type: 'initial_balance',
      date: `${monthKey}-01T00:00:00.000Z`,
      description: 'Saldo Awal',
      amount: totalSaldoAwal,
      icon: 'üí∞',
      color: 'blue',
      metadata: {
        pocketType: 'daily',
        carryOverFromPrevMonth: carryOver?.amount || 0,
        newMonthBudget: newBudget,
        breakdown: {
          carryOver: carryOver?.amount || 0,
          newBudget: newBudget
        },
        isInitialBalance: true
      }
    });
    
  } else if (pocketId === POCKET_IDS.COLD_MONEY) {
    // ‚úÖ TIPE 2: UANG DINGIN (Simple Carry-Over)
    // Saldo Awal = Saldo akhir bulan lalu
    let carryOver = null;
    try {
      carryOver = await getCarryOverForPocket(pocketId, monthKey);
    } catch (error) {
      console.warn('[TIMELINE] Error fetching carry-over for Cold Money:', error);
    }
    const saldoAwal = carryOver?.amount || 0;
    
    // Always show Saldo Awal (even if 0) for consistency
    allTransactions.push({
      id: `initial_${pocketId}`,
      type: 'initial_balance',
      date: `${monthKey}-01T00:00:00.000Z`,
      description: 'Saldo Awal',
      amount: saldoAwal,
      icon: '‚ùÑÔ∏è',
      color: 'blue',
      metadata: {
        pocketType: 'cold_money',
        carryOverFromPrevMonth: saldoAwal,
        fromMonth: carryOver?.fromMonth,
        isInitialBalance: true
      }
    });
    
  } else {
    // ‚úÖ TIPE 3: CUSTOM POCKETS (Simple Carry-Over)
    // Saldo Awal = Saldo akhir bulan lalu
    let carryOver = null;
    try {
      carryOver = await getCarryOverForPocket(pocketId, monthKey);
    } catch (error) {
      console.warn('[TIMELINE] Error fetching carry-over for custom pocket:', error);
    }
    const saldoAwal = carryOver?.amount || 0;
    
    allTransactions.push({
      id: `initial_${pocketId}`,
      type: 'initial_balance',
      date: `${monthKey}-01T00:00:00.000Z`,
      description: 'Saldo Awal',
      amount: saldoAwal,
      icon: 'üéØ',
      color: 'blue',
      metadata: {
        pocketType: 'custom',
        carryOverFromPrevMonth: saldoAwal,
        fromMonth: carryOver?.fromMonth,
        breakdown: carryOver?.breakdown,
        isInitialBalance: true
      }
    });
  }
  
  // ============================================
  // ‚úÖ FASE 3: FILTER TRANSACTIONS BY MONTH
  // ============================================
  
  // 2. Expenses for this pocket (ONLY current month)
  const pocketExpenses = expenses
    .filter((e: any) => 
      e.pocketId === pocketId && 
      !excludedExpenseIds.has(e.id) &&
      isInCurrentMonth(e.date) // ‚úÖ Filter by month!
    )
    .map((e: any) => ({
      id: e.id,
      type: 'expense' as TransactionType,
      date: e.date,
      description: e.name,
      amount: -e.amount,
      icon: e.categoryIcon || 'ShoppingBag',
      color: 'red',
      metadata: {
        category: e.category,
        notes: e.notes,
        groupId: e.groupId
      }
    }));
  
  // 3. Additional income (ONLY current month)
  // Backward compatibility: if pocketId is undefined, default to Cold Money pocket
  const pocketIncome = additionalIncome
    .filter((i: any) => {
      const incomePocketId = i.pocketId || POCKET_IDS.COLD_MONEY;  // ‚úÖ FIX: Typo "Poket" ‚Üí "Pocket"
      return incomePocketId === pocketId && 
             !excludedIncomeIds.has(i.id) &&
             isInCurrentMonth(i.date); // ‚úÖ Filter by month!
    })
    .map((i: any) => {
      // ‚úÖ BACKWARD COMPATIBILITY: Handle missing amountIDR (old data or IDR-only income)
      const incomeAmount = i.amountIDR || i.amount || 0;
      const deduction = i.deduction || 0;
      
      return {
        id: i.id,
        type: 'income' as TransactionType,
        date: i.date,
        description: i.name,
        amount: incomeAmount - deduction,
        icon: 'DollarSign',
        color: 'green',
        metadata: {
          amountUSD: i.amountUSD,
          exchangeRate: i.exchangeRate,
          deduction: i.deduction
        }
      };
    });
  
  // 4. Transfers (ONLY current month)
  const pocketTransfers: any[] = [];
  
  transfers.forEach((t: any) => {
    // ‚úÖ FASE 3: Filter by month!
    if (!isInCurrentMonth(t.date)) return;
    
    // Transfer OUT (from this pocket)
    if (t.fromPocketId === pocketId) {
      // BACKWARD COMPATIBILITY: Use stored name if available, otherwise lookup from pockets array
      const toPocket = pockets.find((p: Pocket) => p.id === t.toPocketId);
      const isUnknownPocket = !t.toPocketName && !toPocket;
      const toPocketName = t.toPocketName || toPocket?.name || 'Kantong Lama (Tidak Aktif)';
      
      pocketTransfers.push({
        id: `${t.id}_out`,
        type: 'transfer' as TransactionType,
        date: t.date,
        description: `Transfer ke ${toPocketName}`,
        amount: -t.amount,
        icon: 'ArrowRight',
        color: 'blue',
        metadata: {
          transferId: t.id,
          direction: 'out',
          fromPocketId: t.fromPocketId,
          toPocketId: t.toPocketId,
          toPocketName: toPocketName,
          note: t.note,
          isUnknownPocket: isUnknownPocket // ‚ö†Ô∏è Flag for old data with missing pocket reference
        }
      });
    }
    
    // Transfer IN (to this pocket)
    if (t.toPocketId === pocketId) {
      // BACKWARD COMPATIBILITY: Use stored name if available, otherwise lookup from pockets array
      const fromPocket = pockets.find((p: Pocket) => p.id === t.fromPocketId);
      const isUnknownPocket = !t.fromPocketName && !fromPocket;
      const fromPocketName = t.fromPocketName || fromPocket?.name || 'Kantong Lama (Tidak Aktif)';
      
      pocketTransfers.push({
        id: `${t.id}_in`,
        type: 'transfer' as TransactionType,
        date: t.date,
        description: `Transfer dari ${fromPocketName}`,
        amount: t.amount,
        icon: 'ArrowLeft',
        color: 'green',
        metadata: {
          transferId: t.id,
          direction: 'in',
          fromPocketId: t.fromPocketId,
          toPocketId: t.toPocketId,
          fromPocketName: fromPocketName,
          note: t.note,
          isUnknownPocket: isUnknownPocket // ‚ö†Ô∏è Flag for old data with missing pocket reference
        }
      });
    }
  });
  
  // Add expenses, income, and transfers
  allTransactions.push(...pocketExpenses);
  allTransactions.push(...pocketIncome);
  allTransactions.push(...pocketTransfers);
  
  // Sort by date ASCENDING (oldest first) - always calculate forward
  allTransactions.sort((a, b) => {
    const dateA = new Date(a.date).getTime();
    const dateB = new Date(b.date).getTime();
    return dateA - dateB;  // ASC
  });
  
  // Calculate balance FORWARD (simple and correct)
  let runningBalance = 0;
  const entries: TimelineEntry[] = [];
  
  allTransactions.forEach(txn => {
    runningBalance += txn.amount;
    entries.push({
      ...txn,
      balanceAfter: runningBalance
    });
  });
  
  // If user wants DESC, reverse the array
  if (sortOrder === 'desc') {
    entries.reverse();
  }
  
  return entries;
}

// ============================================
// ARCHIVE SYSTEM - HELPER FUNCTIONS (OLD/DEPRECATED)
// ‚ö†Ô∏è These use OLD per-month storage, kept for backward compatibility
// ============================================

/**
 * Archive a pocket (must have balance = 0)
 * ‚ö†Ô∏è DEPRECATED - Uses OLD per-month storage system
 */
async function archivePocket_OLD(request: ArchiveRequest): Promise<ArchiveResult> {
  const { pocketId, monthKey, reason } = request;
  
  // 1. Get current pockets
  const pockets = await getPockets(monthKey);
  const pocket = pockets.find((p: Pocket) => p.id === pocketId);
  
  if (!pocket) {
    throw new Error('Pocket not found');
  }
  
  if (pocket.status === 'archived') {
    throw new Error('Pocket already archived');
  }
  
  if (pocket.type === 'primary') {
    throw new Error('Cannot archive primary pockets (Sehari-hari, Uang Dingin)');
  }
  
  // 2. Check balance MUST be 0
  const balance = await calculatePocketBalance(pocketId, monthKey);
  
  if (balance.availableBalance !== 0) {
    throw new Error(
      `Saldo harus Rp 0 sebelum archive. Saldo saat ini: Rp ${balance.availableBalance.toLocaleString('id-ID')}`
    );
  }
  
  // 3. Update pocket status
  pocket.status = 'archived';
  pocket.archivedAt = new Date().toISOString();
  pocket.archivedReason = reason || 'Tidak ada alasan';
  
  // 4. Remove from active pockets list
  const activePockets = pockets.filter((p: Pocket) => p.id !== pocketId);
  await kv.set(`pockets:${monthKey}`, activePockets);
  
  // 5. Save to archived pockets (global, not per month)
  const archivedKey = 'archived_pockets';
  const archived = await kv.get(archivedKey) || [];
  archived.push(pocket);
  await kv.set(archivedKey, archived);
  
  // 6. Log to archive history
  const historyKey = 'archive_history';
  const history = await kv.get(historyKey) || [];
  const historyEntry: ArchiveHistoryEntry = {
    pocketId: pocket.id,
    pocketName: pocket.name,
    archivedAt: pocket.archivedAt,
    reason: pocket.archivedReason,
    balanceAtArchive: balance.availableBalance
  };
  history.push(historyEntry);
  await kv.set(historyKey, history);
  
  return {
    success: true,
    archivedPocket: pocket,
    message: `Kantong "${pocket.name}" berhasil diarsipkan`
  };
}

/**
 * Unarchive a pocket (restore to active)
 * ‚ö†Ô∏è DEPRECATED - Uses OLD per-month storage system
 */
async function unarchivePocket_OLD(pocketId: string, monthKey: string): Promise<ArchiveResult> {
  // 1. Get archived pockets
  const archivedKey = 'archived_pockets';
  const archived = await kv.get(archivedKey) || [];
  const pocket = archived.find((p: Pocket) => p.id === pocketId);
  
  if (!pocket) {
    throw new Error('Archived pocket not found');
  }
  
  // 2. Restore pocket
  pocket.status = 'active';
  delete pocket.archivedAt;
  delete pocket.archivedReason;
  
  // 3. Remove from archived list
  const remainingArchived = archived.filter((p: Pocket) => p.id !== pocketId);
  await kv.set(archivedKey, remainingArchived);
  
  // 4. Add back to active pockets
  const pockets = await getPockets(monthKey);
  pockets.push(pocket);
  await kv.set(`pockets:${monthKey}`, pockets);
  
  return {
    success: true,
    archivedPocket: pocket,
    message: `Kantong "${pocket.name}" berhasil dipulihkan`
  };
}

/**
 * Get archived pockets
 * ‚ö†Ô∏è DEPRECATED - Uses OLD archive storage system
 */
async function getArchivedPockets_OLD(): Promise<Pocket[]> {
  const archivedKey = 'archived_pockets';
  return await kv.get(archivedKey) || [];
}

/**
 * Get archive history
 * ‚ö†Ô∏è DEPRECATED - Uses OLD archive storage system
 */
async function getArchiveHistory_OLD(): Promise<ArchiveHistoryEntry[]> {
  const historyKey = 'archive_history';
  return await kv.get(historyKey) || [];
}

// REMOVED: Duplicate generatePocketTimeline function (kept the first one at line 604)

/**
 * Validate transfer
 */
function validateTransfer(
  transfer: { fromPocketId: string; toPocketId: string; amount: number },
  fromBalance: PocketBalance
): { valid: boolean; error?: string } {
  if (transfer.fromPocketId === transfer.toPocketId) {
    return { valid: false, error: 'Tidak bisa transfer ke kantong yang sama' };
  }
  
  if (transfer.amount <= 0) {
    return { valid: false, error: 'Jumlah transfer harus lebih dari 0' };
  }
  
  if (fromBalance.availableBalance < transfer.amount) {
    return { 
      valid: false, 
      error: `Saldo tidak cukup. Tersedia: Rp ${fromBalance.availableBalance.toLocaleString('id-ID')}` 
    };
  }
  
  return { valid: true };
}

const app = new Hono();

// üî• CRITICAL DEBUG: Log ALL incoming requests FIRST
app.use('*', async (c, next) => {
  const url = new URL(c.req.url);
  console.log(`\nüî• [INCOMING] ${c.req.method} ${url.pathname}`);
  console.log(`üî• [INCOMING] Time: ${new Date().toISOString()}`);
  await next();
  console.log(`‚úÖ [COMPLETED] ${c.req.method} ${url.pathname}\n`);
});

// Enable logger
app.use('*', logger(console.log));

// Enable CORS for all routes and methods
app.use(
  "/*",
  cors({
    origin: "*",
    allowHeaders: ["Content-Type", "Authorization"],
    allowMethods: ["GET", "POST", "PUT", "DELETE", "OPTIONS"],
    exposeHeaders: ["Content-Length"],
    maxAge: 600,
  }),
);

// Health check endpoint
app.get("/make-server-3adbeaf1/health", (c) => {
  return c.json({ status: "ok" });
});

// Get budget for specific month (with all related data)
app.get("/make-server-3adbeaf1/budget/:year/:month", async (c) => {
  try {
    const year = c.req.param("year");
    const month = c.req.param("month");
    const monthKey = `${year}-${month}`;
    
    // Fetch all data in parallel for better performance
    const [budget, expenses, additionalIncomes, previousMonthRemaining] = await Promise.all([
      kv.get(`budget:${monthKey}`),
      kv.getByPrefix(`expense:${monthKey}:`),
      kv.getByPrefix(`income:${monthKey}:`),
      calculatePreviousMonthRemaining(year, month)
    ]);
    
    console.log(`üîç [GET BUDGET DEBUG] ${monthKey}:`);
    console.log(`  ‚îú‚îÄ Query prefix: expense:${monthKey}:`);
    console.log(`  ‚îú‚îÄ Found ${expenses?.length || 0} expenses`);
    if (expenses && expenses.length > 0) {
      console.log(`  ‚îú‚îÄ First 3 expenses:`);
      expenses.slice(0, 3).forEach((exp: any) => {
        const expDate = new Date(exp.date);
        const expMonth = `${expDate.getFullYear()}-${String(expDate.getMonth() + 1).padStart(2, '0')}`;
        console.log(`  ‚îÇ   ‚Ä¢ ${exp.name}: date=${expMonth}, id=${exp.id}`);
      });
    }
    console.log(`  ‚îî‚îÄ ÔøΩÔøΩÔøΩ Expenses filtered by PREFIX (storage key), not date field`);
    
    return c.json({
      budget: budget || {
        initialBudget: 0,
        notes: "",
        incomeDeduction: 0,
      },
      expenses: expenses || [],
      additionalIncomes: additionalIncomes || [],
      previousMonthRemaining: previousMonthRemaining ?? null
    });
  } catch (error: any) {
    console.log(`Error fetching budget data: ${error.message}`);
    return c.json({ error: `Failed to get budget: ${error.message}` }, 500);
  }
});

// Helper function to calculate previous month remaining
async function calculatePreviousMonthRemaining(year: string, month: string): Promise<number | null> {
  try {
    // Calculate previous month and year
    let prevMonth = parseInt(month) - 1;
    let prevYear = parseInt(year);
    
    if (prevMonth === 0) {
      prevMonth = 12;
      prevYear = prevYear - 1;
    }
    
    const prevMonthKey = `${prevYear}-${prevMonth.toString().padStart(2, '0')}`;
    
    // Fetch previous month data
    // ‚úÖ BACKWARD COMPATIBILITY: Old data may have carryover field, ignore it
    const prevBudget = await kv.get(`budget:${prevMonthKey}`) || { initialBudget: 0, incomeDeduction: 0 };
    const prevExpenses = await kv.getByPrefix(`expense:${prevMonthKey}:`) || [];
    const prevIncomes = await kv.getByPrefix(`income:${prevMonthKey}:`) || [];
    
    // Calculate previous month remaining
    const prevGrossIncome = prevIncomes.reduce((sum: number, income: any) => sum + (income.amountIDR || 0), 0);
    const prevTotalAdditionalIncome = prevGrossIncome - (prevBudget.incomeDeduction || 0);
    // ‚úÖ CARRYOVER REMOVED: Sistem kantong sudah handle carry-over otomatis
    const prevTotalIncome = Number(prevBudget.initialBudget || 0) + prevTotalAdditionalIncome;
    const prevTotalExpenses = prevExpenses.reduce((sum: number, expense: any) => sum + (expense.amount || 0), 0);
    const remaining = prevTotalIncome - prevTotalExpenses;
    
    return remaining;
  } catch (error) {
    console.log(`Error calculating previous month remaining: ${error}`);
    return null;
  }
}

// Save/update budget for specific month
app.post("/make-server-3adbeaf1/budget/:year/:month", async (c) => {
  try {
    const year = c.req.param("year");
    const month = c.req.param("month");
    const key = `budget:${year}-${month}`;
    
    const body = await c.req.json();
    const { initialBudget, notes, incomeDeduction } = body;
    
    // ‚úÖ CARRYOVER REMOVED: Sistem kantong sudah handle carry-over otomatis
    // Carryover manual tidak diperlukan lagi karena setiap kantong memiliki
    // logic carry-over sendiri sesuai tipenya (Daily, Cold Money, Custom)
    const budgetData = {
      initialBudget: Number(initialBudget) || 0,
      notes: notes || "",
      incomeDeduction: Number(incomeDeduction) || 0,
      updatedAt: new Date().toISOString(),
    };
    
    await kv.set(key, budgetData);
    
    return c.json({ success: true, data: budgetData });
  } catch (error: any) {
    return c.json({ error: `Failed to save budget: ${error.message}` }, 500);
  }
});

// Get all expenses for specific month
app.get("/make-server-3adbeaf1/expenses/:year/:month", async (c) => {
  try {
    const year = c.req.param("year");
    const month = c.req.param("month");
    const prefix = `expense:${year}-${month}:`;
    
    const expenses = await kv.getByPrefix(prefix);
    
    return c.json(expenses || []);
  } catch (error: any) {
    return c.json({ error: `Failed to get expenses: ${error.message}` }, 500);
  }
});

// Add new expense
app.post("/make-server-3adbeaf1/expenses/:year/:month", async (c) => {
  try {
    const year = c.req.param("year");
    const month = c.req.param("month");
    const body = await c.req.json();
    
    const { name, amount, date, items, color, fromIncome, currency, originalAmount, exchangeRate, conversionType, deduction, pocketId, groupId, category, emoji } = body;
    
    if (!name || amount === undefined) {
      return c.json({ error: "Name and amount are required" }, 400);
    }
    
    console.log(`[Add Single Expense] Received date: ${date} | Name: ${name}`);
    
    // Parse date: if date is in YYYY-MM-DD format, add time at noon to avoid timezone issues
    let expenseDate;
    if (date) {
      if (date.includes('T')) {
        // Already has time component
        expenseDate = date;
      } else {
        // Just a date (YYYY-MM-DD)
        // CRITICAL FIX: Use noon (12:00) instead of current time to avoid timezone shift
        // This ensures the date stays consistent regardless of timezone
        expenseDate = `${date}T12:00:00.000Z`;
      }
    } else {
      expenseDate = new Date().toISOString();
    }
    
    console.log(`[Add Single Expense] Final date stored: ${expenseDate}`);
    
    // ‚úÖ FIX: Extract year-month from ACTUAL expense date, not URL params!
    // This ensures expenses are stored in the correct month bucket
    const actualDate = new Date(expenseDate);
    const actualYear = actualDate.getUTCFullYear();
    const actualMonth = String(actualDate.getUTCMonth() + 1).padStart(2, '0');
    const actualMonthKey = `${actualYear}-${actualMonth}`;
    
    const expenseId = crypto.randomUUID();
    const key = `expense:${actualMonthKey}:${expenseId}`;
    
    console.log(`üîç [ADD EXPENSE DEBUG]`);
    console.log(`  ‚îú‚îÄ URL params: year=${year}, month=${month}`);
    console.log(`  ‚îú‚îÄ Expense date: ${expenseDate}`);
    console.log(`  ‚îú‚îÄ Extracted from date: year=${actualYear}, month=${actualMonth}`);
    console.log(`  ‚îú‚îÄ Storage key: ${key}`);
    console.log(`  ‚îî‚îÄ ‚úÖ Using date-based key (NOT URL params!)`);
    
    const expenseData = {
      id: expenseId,
      name,
      amount: Number(amount),
      date: expenseDate,
      pocketId: pocketId || POCKET_IDS.DAILY, // Default to daily pocket
      ...(items && items.length > 0 ? { items } : {}),
      ...(color ? { color } : {}),
      ...(emoji ? { emoji } : {}),
      ...(fromIncome ? { fromIncome: true } : {}),
      ...(currency ? { currency } : {}),
      ...(originalAmount !== undefined ? { originalAmount: Number(originalAmount) } : {}),
      ...(exchangeRate !== undefined ? { exchangeRate: Number(exchangeRate) } : {}),
      ...(conversionType ? { conversionType } : {}),
      ...(deduction !== undefined ? { deduction: Number(deduction) } : {}),
      ...(groupId ? { groupId } : {}),
      ...(category !== undefined ? { category } : {}), // üîß FIX: Allow empty string
      createdAt: new Date().toISOString(),
    };
    
    await kv.set(key, expenseData);
    
    return c.json({ success: true, data: expenseData });
  } catch (error: any) {
    return c.json({ error: `Failed to add expense: ${error.message}` }, 500);
  }
});

// Add multiple expenses at once (batch)
app.post("/make-server-3adbeaf1/expenses/:year/:month/batch", async (c) => {
  try {
    const year = c.req.param("year");
    const month = c.req.param("month");
    const body = await c.req.json();
    
    const { expenses } = body;
    
    if (!Array.isArray(expenses) || expenses.length === 0) {
      return c.json({ error: "Expenses array is required" }, 400);
    }
    
    const addedExpenses = [];
    const currentTime = new Date();
    
    console.log(`[Add Batch Expenses] Processing ${expenses.length} expenses`);
    
    for (const expense of expenses) {
      const { name, amount, date, items, color, fromIncome, currency, originalAmount, exchangeRate, conversionType, deduction, pocketId, groupId, category, emoji } = expense;
      
      if (!name || amount === undefined) {
        continue; // Skip invalid entries
      }
      
      console.log(`[Batch Item] Received date: ${date} | Name: ${name}`);
      
      // Parse date: if date is in YYYY-MM-DD format, add time at noon to avoid timezone issues
      let expenseDate;
      if (date) {
        if (date.includes('T')) {
          expenseDate = date;
        } else {
          // CRITICAL FIX: Use noon (12:00) instead of current time to avoid timezone shift
          // This ensures the date stays consistent regardless of timezone
          expenseDate = `${date}T12:00:00.000Z`;
        }
      } else {
        expenseDate = currentTime.toISOString();
      }
      
      // ‚úÖ FIX: Extract year-month from ACTUAL expense date, not URL params!
      const actualDate = new Date(expenseDate);
      const actualYear = actualDate.getUTCFullYear();
      const actualMonth = String(actualDate.getUTCMonth() + 1).padStart(2, '0');
      const actualMonthKey = `${actualYear}-${actualMonth}`;
      
      const expenseId = crypto.randomUUID();
      const key = `expense:${actualMonthKey}:${expenseId}`;
      
      console.log(`üîç [BATCH ITEM DEBUG] ${name}: URL=${year}-${month} | Date=${actualYear}-${actualMonth} | Key=${key}`);
      
      const expenseData = {
        id: expenseId,
        name,
        amount: Number(amount),
        date: expenseDate,
        pocketId: pocketId || POCKET_IDS.DAILY,
        ...(items && items.length > 0 ? { items } : {}),
        ...(color ? { color } : {}),
        ...(emoji ? { emoji } : {}),
        ...(fromIncome ? { fromIncome: true } : {}),
        ...(currency ? { currency } : {}),
        ...(originalAmount !== undefined ? { originalAmount: Number(originalAmount) } : {}),
        ...(exchangeRate !== undefined ? { exchangeRate: Number(exchangeRate) } : {}),
        ...(conversionType ? { conversionType } : {}),
        ...(deduction !== undefined ? { deduction: Number(deduction) } : {}),
        ...(groupId ? { groupId } : {}),
        ...(category !== undefined ? { category } : {}), // üîß FIX: Allow empty string
        createdAt: currentTime.toISOString(),
      };
      
      await kv.set(key, expenseData);
      addedExpenses.push(expenseData);
    }
    
    return c.json({ success: true, data: addedExpenses, count: addedExpenses.length });
  } catch (error: any) {
    return c.json({ error: `Failed to add expenses: ${error.message}` }, 500);
  }
});

// Delete expense
app.delete("/make-server-3adbeaf1/expenses/:year/:month/:id", async (c) => {
  try {
    const year = c.req.param("year");
    const month = c.req.param("month");
    const id = c.req.param("id");
    const key = `expense:${year}-${month}:${id}`;
    
    console.log(`[Delete Expense ${id}] Deleting key: ${key}`);
    
    await kv.del(key);
    
    console.log(`[Delete Expense ${id}] ‚úÖ Deleted successfully`);
    
    return c.json({ success: true });
  } catch (error: any) {
    return c.json({ error: `Failed to delete expense: ${error.message}` }, 500);
  }
});

// Update expense
app.put("/make-server-3adbeaf1/expenses/:year/:month/:id", async (c) => {
  try {
    const urlYear = c.req.param("year");
    const urlMonth = c.req.param("month");
    const id = c.req.param("id");
    const oldKey = `expense:${urlYear}-${urlMonth}:${id}`;
    const body = await c.req.json();
    
    const { name, amount, date, items, color, fromIncome, currency, originalAmount, exchangeRate, conversionType, deduction, pocketId, groupId, category } = body;
    
    if (!name || amount === undefined) {
      return c.json({ error: "Name and amount are required" }, 400);
    }
    
    // Get existing expense to preserve createdAt, pocketId, and groupId if not provided
    const existingExpense = await kv.get(oldKey);
    
    console.log(`[Edit Expense ${id}] Received category:`, category, '| Existing category:', existingExpense?.category);
    console.log(`[Edit Expense ${id}] Received date:`, date, '| Existing date:', existingExpense?.date);
    
    // ‚úÖ TIMEZONE FIX: Parse date correctly to avoid +1 day bug
    // When frontend sends "YYYY-MM-DD", we need to preserve the EXACT timestamp from existing expense
    // The bug was: getHours() returns LOCAL time, but we applied it to a date created with local constructor,
    // causing double timezone application!
    let expenseDate;
    let dateChanged = false;
    if (date) {
      if (date.includes('T')) {
        // Already has full ISO timestamp - use it directly
        expenseDate = date;
        // Check if date changed (compare UTC date part only)
        if (existingExpense?.date) {
          const oldDateOnly = new Date(existingExpense.date).toISOString().split('T')[0];
          const newDateOnly = new Date(date).toISOString().split('T')[0];
          dateChanged = oldDateOnly !== newDateOnly;
        }
      } else {
        // Just a date string (YYYY-MM-DD) from frontend
        // We need to preserve the EXACT time from existing expense, but change the date part
        if (existingExpense?.date && existingExpense.date.includes('T')) {
          // Get the local date from existing expense to compare
          const existingDateObj = new Date(existingExpense.date);
          const existingLocalYear = existingDateObj.getFullYear();
          const existingLocalMonth = existingDateObj.getMonth() + 1;
          const existingLocalDay = existingDateObj.getDate();
          const oldDateOnly = `${existingLocalYear}-${String(existingLocalMonth).padStart(2, '0')}-${String(existingLocalDay).padStart(2, '0')}`;
          dateChanged = oldDateOnly !== date;
          
          // Extract ONLY the time part (HH:mm:ss.SSS) from existing ISO timestamp
          const timePart = existingExpense.date.split('T')[1]; // e.g., "16:00:00.000Z"
          
          // Combine new date with EXACT time from existing (preserving UTC timezone!)
          expenseDate = `${date}T${timePart}`;
        } else {
          // No existing timestamp - create new one with current time
          dateChanged = true;
          const currentTime = new Date();
          const [year, month, day] = date.split('-').map(Number);
          const dateObj = new Date(year, month - 1, day);
          dateObj.setHours(currentTime.getHours());
          dateObj.setMinutes(currentTime.getMinutes());
          dateObj.setSeconds(currentTime.getSeconds());
          expenseDate = dateObj.toISOString();
        }
      }
    } else {
      expenseDate = existingExpense?.date || new Date().toISOString();
    }
    
    // If date changed, remove groupId to ungroup this expense from others
    // Otherwise preserve groupId if it exists
    let finalGroupId;
    if (groupId !== undefined) {
      // Explicitly setting groupId (from frontend)
      finalGroupId = groupId;
    } else if (dateChanged) {
      // Date changed - remove groupId to ungroup
      console.log(`[Edit Expense ${id}] Date changed! Removing groupId. Old groupId:`, existingExpense?.groupId);
      finalGroupId = undefined;
    } else {
      // Date didn't change - preserve existing groupId
      finalGroupId = existingExpense?.groupId;
    }
    
    console.log(`[Edit Expense ${id}] Final expense date:`, expenseDate, '| Date changed:', dateChanged, '| GroupId:', finalGroupId);
    
    // üîß CRITICAL FIX: Preserve category from existing expense if not provided in update
    const finalCategory = category !== undefined ? category : existingExpense?.category;
    
    const expenseData = {
      id,
      name,
      amount: Number(amount),
      date: expenseDate,
      pocketId: pocketId || existingExpense?.pocketId || POCKET_IDS.DAILY,
      ...(items && items.length > 0 ? { items } : {}),
      ...(color !== undefined ? { color } : existingExpense?.color ? { color: existingExpense.color } : {}),
      ...(fromIncome ? { fromIncome: true } : {}),
      ...(currency !== undefined ? { currency } : existingExpense?.currency ? { currency: existingExpense.currency } : {}),
      ...(originalAmount !== undefined ? { originalAmount: Number(originalAmount) } : existingExpense?.originalAmount !== undefined ? { originalAmount: existingExpense.originalAmount } : {}),
      ...(exchangeRate !== undefined ? { exchangeRate: Number(exchangeRate) } : existingExpense?.exchangeRate !== undefined ? { exchangeRate: existingExpense.exchangeRate } : {}),
      ...(conversionType !== undefined ? { conversionType } : existingExpense?.conversionType ? { conversionType: existingExpense.conversionType } : {}),
      ...(deduction !== undefined ? { deduction: Number(deduction) } : existingExpense?.deduction !== undefined ? { deduction: existingExpense.deduction } : {}),
      ...(finalGroupId ? { groupId: finalGroupId } : {}),
      ...(finalCategory !== undefined ? { category: finalCategory } : {}), // Include category
      createdAt: existingExpense?.createdAt || new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    };
    
    console.log(`[Edit Expense ${id}] Final category being saved:`, finalCategory);
    
    // üîß CRITICAL FIX: Extract ACTUAL month from date field (like POST does)
    // This handles migration from old wrong keys to correct keys!
    const actualDate = new Date(expenseDate);
    const actualYear = actualDate.getUTCFullYear();
    const actualMonth = String(actualDate.getUTCMonth() + 1).padStart(2, '0');
    const actualMonthKey = `${actualYear}-${actualMonth}`;
    const correctKey = `expense:${actualMonthKey}:${id}`;
    
    // Check if key needs migration (month changed)
    const oldMonthKey = `${urlYear}-${urlMonth}`;
    const keyNeedsMigration = (actualMonthKey !== oldMonthKey);
    
    if (keyNeedsMigration) {
      // üîÑ MIGRATION: Delete old key, save to correct key
      console.log(`[Edit Expense ${id}] üîÑ MIGRATING from ${oldKey} to ${correctKey}`);
      console.log(`  ‚îî‚îÄ Old month: ${oldMonthKey} | New month: ${actualMonthKey}`);
      
      // Delete old key
      await kv.del(oldKey);
      
      // Save to correct key
      await kv.set(correctKey, expenseData);
      
      console.log(`[Edit Expense ${id}] ‚úÖ Migration complete!`);
      
      // üîÑ CRITICAL: Regenerate carry-over for affected months
      // When expense moves from Month B to Month A, we need to regenerate:
      // 1. Carry-over from Month A ‚Üí next month (includes migrated expense)
      // 2. Carry-over from Month B ‚Üí next month (excludes migrated expense)
      try {
        console.log(`[Edit Expense ${id}] üîÑ Regenerating carry-overs for affected months...`);
        
        // Regenerate carry-over from OLD month (where expense was removed)
        await generateCarryOversForNextMonth(oldMonthKey);
        
        // Regenerate carry-over from NEW month (where expense was added)
        await generateCarryOversForNextMonth(actualMonthKey);
        
        console.log(`[Edit Expense ${id}] ‚úÖ Carry-overs regenerated!`);
      } catch (error) {
        console.error(`[Edit Expense ${id}] ‚ö†Ô∏è Error regenerating carry-overs:`, error);
        // Don't fail the request - carry-over will be regenerated on next month navigation
      }
    } else {
      // No migration needed - just update
      console.log(`[Edit Expense ${id}] ‚úÖ Updating same key: ${correctKey}`);
      await kv.set(correctKey, expenseData);
      
      // üîÑ Regenerate carry-over for current month (expense amount might have changed)
      try {
        console.log(`[Edit Expense ${id}] üîÑ Regenerating carry-over for current month...`);
        await generateCarryOversForNextMonth(actualMonthKey);
        console.log(`[Edit Expense ${id}] ‚úÖ Carry-over regenerated!`);
      } catch (error) {
        console.error(`[Edit Expense ${id}] ‚ö†Ô∏è Error regenerating carry-over:`, error);
      }
    }
    
    return c.json({ success: true, data: expenseData });
  } catch (error: any) {
    return c.json({ error: `Failed to update expense: ${error.message}` }, 500);
  }
});

// Get all additional incomes for specific month
app.get("/make-server-3adbeaf1/additional-income/:year/:month", async (c) => {
  try {
    const year = c.req.param("year");
    const month = c.req.param("month");
    const prefix = `income:${year}-${month}:`;
    
    const incomes = await kv.getByPrefix(prefix);
    
    return c.json(incomes || []);
  } catch (error: any) {
    return c.json({ error: `Failed to get additional incomes: ${error.message}` }, 500);
  }
});

// Add new additional income
app.post("/make-server-3adbeaf1/additional-income/:year/:month", async (c) => {
  try {
    const year = c.req.param("year");
    const month = c.req.param("month");
    const body = await c.req.json();
    
    const { name, amount, currency, exchangeRate, amountIDR, conversionType, date, deduction, pocketId } = body;
    

    
    if (!name || amount === undefined) {
      return c.json({ error: "Name and amount are required" }, 400);
    }
    
    if (!pocketId) {
      return c.json({ error: "Pocket ID is required" }, 400);
    }
    
    const incomeId = crypto.randomUUID();
    const key = `income:${year}-${month}:${incomeId}`;
    
    // Parse date: if date is in YYYY-MM-DD format, use UTC noon standard
    let incomeDate;
    if (date) {
      if (date.includes('T')) {
        // Already has time component
        incomeDate = date;
      } else {
        // Just a date (YYYY-MM-DD), use UTC noon to avoid timezone issues
        incomeDate = `${date}T12:00:00.000Z`;
      }
    } else {
      incomeDate = new Date().toISOString();
    }
    
    const incomeData = {
      id: incomeId,
      name,
      amount: Number(amount), // Legacy field (keep for backward compat)
      amountUSD: Number(amount), // ‚úÖ NEW: Proper field name for TypeScript
      currency: currency || "IDR",
      exchangeRate: exchangeRate ? Number(exchangeRate) : null,
      amountIDR: Number(amountIDR),
      conversionType: conversionType || "manual",
      date: incomeDate,
      deduction: Number(deduction) || 0,
      pocketId,
      createdAt: new Date().toISOString(),
    };
    
    await kv.set(key, incomeData);
    
    // Store income name for autocomplete suggestions
    const nameKey = `income-name:${name.toLowerCase()}`;
    await kv.set(nameKey, { name, lastUsed: new Date().toISOString() });
    
    return c.json({ success: true, data: incomeData });
  } catch (error: any) {
    return c.json({ error: `Failed to add additional income: ${error.message}` }, 500);
  }
});

// Delete additional income
app.delete("/make-server-3adbeaf1/additional-income/:year/:month/:id", async (c) => {
  try {
    const year = c.req.param("year");
    const month = c.req.param("month");
    const id = c.req.param("id");
    const key = `income:${year}-${month}:${id}`;
    
    await kv.del(key);
    
    return c.json({ success: true });
  } catch (error: any) {
    return c.json({ error: `Failed to delete additional income: ${error.message}` }, 500);
  }
});

// Update additional income
app.put("/make-server-3adbeaf1/additional-income/:year/:month/:id", async (c) => {
  try {
    const urlYear = c.req.param("year");
    const urlMonth = c.req.param("month");
    const id = c.req.param("id");
    const oldKey = `income:${urlYear}-${urlMonth}:${id}`;
    const body = await c.req.json();
    
    const { name, amount, currency, exchangeRate, amountIDR, conversionType, date, deduction, pocketId } = body;
    
    if (!name || amount === undefined) {
      return c.json({ error: "Name and amount are required" }, 400);
    }
    
    // Get existing data to preserve createdAt and pocketId
    const existingIncome = await kv.get(oldKey);
    
    // Use provided pocketId, or fallback to existing pocketId, or default to cold money
    const finalPocketId = pocketId || existingIncome?.pocketId || POCKET_IDS.COLD_MONEY;
    
    // Parse date: if date is in YYYY-MM-DD format, use UTC noon standard
    let incomeDate;
    if (date) {
      if (date.includes('T')) {
        // Already has time component
        incomeDate = date;
      } else {
        // Just a date (YYYY-MM-DD), use UTC noon to avoid timezone issues
        incomeDate = `${date}T12:00:00.000Z`;
      }
    } else {
      incomeDate = existingIncome?.date || new Date().toISOString();
    }
    
    const incomeData = {
      id,
      name,
      amount: Number(amount), // Legacy field (keep for backward compat)
      amountUSD: Number(amount), // ‚úÖ NEW: Proper field name for TypeScript
      currency: currency || "IDR",
      exchangeRate: exchangeRate ? Number(exchangeRate) : null,
      amountIDR: Number(amountIDR),
      conversionType: conversionType || "manual",
      date: incomeDate,
      deduction: Number(deduction) || 0,
      pocketId: finalPocketId,
      createdAt: existingIncome?.createdAt || new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    };
    
    console.log(`[Edit Income ${id}] Received date:`, date, '| Parsed date:', incomeDate);
    
    // üîß CRITICAL FIX: Extract ACTUAL month from date field (same as expense auto-migration)
    // This handles migration from old wrong keys to correct keys!
    const actualDate = new Date(incomeDate);
    const actualYear = actualDate.getUTCFullYear();
    const actualMonth = String(actualDate.getUTCMonth() + 1).padStart(2, '0');
    const actualMonthKey = `${actualYear}-${actualMonth}`;
    const correctKey = `income:${actualMonthKey}:${id}`;
    
    // Check if key needs migration (month changed)
    const oldMonthKey = `${urlYear}-${urlMonth}`;
    const keyNeedsMigration = (actualMonthKey !== oldMonthKey);
    
    if (keyNeedsMigration) {
      // üîÑ MIGRATION: Delete old key, save to correct key
      console.log(`[Edit Income ${id}] üîÑ MIGRATING from ${oldKey} to ${correctKey}`);
      console.log(`  ‚îî‚îÄ Old month: ${oldMonthKey} | New month: ${actualMonthKey}`);
      
      // Delete old key
      await kv.del(oldKey);
      
      // Save to correct key
      await kv.set(correctKey, incomeData);
      
      console.log(`[Edit Income ${id}] ‚úÖ Migration complete!`);
      
      // üîÑ CRITICAL: Regenerate carry-over for affected months
      // When income moves from Month B to Month A, we need to regenerate:
      // 1. Carry-over from Month A ‚Üí next month (includes migrated income)
      // 2. Carry-over from Month B ‚Üí next month (excludes migrated income)
      try {
        console.log(`[Edit Income ${id}] üîÑ Regenerating carry-overs for affected months...`);
        
        // Regenerate carry-over from OLD month (where income was removed)
        await generateCarryOversForNextMonth(oldMonthKey);
        
        // Regenerate carry-over from NEW month (where income was added)
        await generateCarryOversForNextMonth(actualMonthKey);
        
        console.log(`[Edit Income ${id}] ‚úÖ Carry-overs regenerated!`);
      } catch (error) {
        console.error(`[Edit Income ${id}] ‚ö†Ô∏è Error regenerating carry-overs:`, error);
        // Don't fail the request - carry-over will be regenerated on next month navigation
      }
    } else {
      // No migration needed - just update
      console.log(`[Edit Income ${id}] ‚úÖ Updating same key: ${correctKey}`);
      await kv.set(correctKey, incomeData);
      
      // üîÑ Regenerate carry-over for current month (income amount might have changed)
      try {
        console.log(`[Edit Income ${id}] ÔøΩÔøΩÔøΩ Regenerating carry-over for current month...`);
        await generateCarryOversForNextMonth(actualMonthKey);
        console.log(`[Edit Income ${id}] ‚úÖ Carry-over regenerated!`);
      } catch (error) {
        console.error(`[Edit Income ${id}] ‚ö†Ô∏è Error regenerating carry-over:`, error);
      }
    }
    
    // Update income name for autocomplete suggestions
    const nameKey = `income-name:${name.toLowerCase()}`;
    await kv.set(nameKey, { name, lastUsed: new Date().toISOString() });
    
    return c.json({ success: true, data: incomeData });
  } catch (error: any) {
    return c.json({ error: `Failed to update additional income: ${error.message}` }, 500);
  }
});

// Get income name suggestions
app.get("/make-server-3adbeaf1/income-names", async (c) => {
  try {
    const prefix = "income-name:";
    const names = await kv.getByPrefix(prefix);
    
    // Sort by last used
    const sortedNames = (names || [])
      .sort((a, b) => new Date(b.lastUsed).getTime() - new Date(a.lastUsed).getTime())
      .map(item => item.name);
    
    return c.json(sortedNames);
  } catch (error: any) {
    return c.json({ error: `Failed to get income names: ${error.message}` }, 500);
  }
});

// Get exchange rate from USD to IDR
app.get("/make-server-3adbeaf1/exchange-rate", async (c) => {
  try {
    const apiKey = Deno.env.get("EXCHANGE_RATE_API_KEY");
    
    if (!apiKey) {
      return c.json({ error: "Exchange rate API key not configured" }, 500);
    }
    
    const response = await fetch(
      `https://v6.exchangerate-api.com/v6/${apiKey}/pair/USD/IDR`
    );
    
    if (!response.ok) {
      throw new Error("Failed to fetch exchange rate from API");
    }
    
    const data = await response.json();
    
    if (data.result !== "success") {
      throw new Error("Exchange rate API returned error");
    }
    
    return c.json({ 
      rate: data.conversion_rate,
      lastUpdated: data.time_last_update_utc 
    });
  } catch (error: any) {
    return c.json({ error: `Failed to get exchange rate: ${error.message}` }, 500);
  }
});

// Get all fixed expense templates
app.get("/make-server-3adbeaf1/templates", async (c) => {
  try {
    const prefix = "template:";
    const templates = await kv.getByPrefix(prefix);
    
    return c.json(templates || []);
  } catch (error: any) {
    return c.json({ error: `Failed to get templates: ${error.message}` }, 500);
  }
});

// Add new fixed expense template
app.post("/make-server-3adbeaf1/templates", async (c) => {
  try {
    const body = await c.req.json();
    const { name, items, color, emoji } = body;
    
    if (!name || !items || !Array.isArray(items)) {
      return c.json({ error: "Name and items are required" }, 400);
    }
    
    const templateId = crypto.randomUUID();
    const key = `template:${templateId}`;
    
    const templateData = {
      id: templateId,
      name,
      items,
      ...(color !== undefined && color !== "" ? { color } : {}),
      ...(emoji !== undefined && emoji !== "" ? { emoji } : {}),
      createdAt: new Date().toISOString(),
    };
    
    await kv.set(key, templateData);
    
    console.log(`‚úÖ Template created - ID: ${templateId}, Name: ${name}, Emoji: ${emoji || '(none)'}, Color: ${color || '(none)'}`);
    
    return c.json({ success: true, data: templateData });
  } catch (error: any) {
    console.error(`‚ùå Failed to add template: ${error.message}`);
    return c.json({ error: `Failed to add template: ${error.message}` }, 500);
  }
});

// Update fixed expense template
app.put("/make-server-3adbeaf1/templates/:id", async (c) => {
  try {
    const id = c.req.param("id");
    const key = `template:${id}`;
    const body = await c.req.json();
    
    const { name, items, color, emoji } = body;
    
    if (!name || !items || !Array.isArray(items)) {
      return c.json({ error: "Name and items are required" }, 400);
    }
    
    // üîß FIX: Load existing template first to preserve all fields
    const existingTemplate = await kv.get(key);
    
    // Merge with existing data, preserving fields like createdAt
    const templateData = {
      ...(existingTemplate || {}), // Preserve existing fields
      id,
      name,
      items,
      ...(color !== undefined && color !== "" ? { color } : {}),
      ...(emoji !== undefined && emoji !== "" ? { emoji } : {}),
      updatedAt: new Date().toISOString(),
    };
    
    // If color or emoji is explicitly cleared (empty string), remove from object
    if (color === "") {
      delete templateData.color;
    }
    if (emoji === "") {
      delete templateData.emoji;
    }
    
    await kv.set(key, templateData);
    
    console.log(`‚úÖ Template updated - ID: ${id}, Emoji: ${emoji || '(none)'}, Color: ${color || '(none)'}`);
    
    return c.json({ success: true, data: templateData });
  } catch (error: any) {
    console.error(`‚ùå Failed to update template: ${error.message}`);
    return c.json({ error: `Failed to update template: ${error.message}` }, 500);
  }
});

// Delete fixed expense template
app.delete("/make-server-3adbeaf1/templates/:id", async (c) => {
  try {
    const id = c.req.param("id");
    const key = `template:${id}`;
    
    await kv.del(key);
    
    return c.json({ success: true });
  } catch (error: any) {
    return c.json({ error: `Failed to delete template: ${error.message}` }, 500);
  }
});

// üîß MIGRATION: Add groupId to expenses created from templates
app.post("/make-server-3adbeaf1/migrate-template-groupids", async (c) => {
  try {
    console.log('[MIGRATION] Starting template groupId migration...');
    
    // 1. Get all templates
    const templates = await kv.getByPrefix("template:");
    console.log(`[MIGRATION] Found ${templates.length} templates`);
    
    if (templates.length === 0) {
      return c.json({
        success: true,
        message: 'No templates found',
        stats: { templatesFound: 0, expensesUpdated: 0, expensesSkipped: 0 }
      });
    }
    
    // Create map: template name -> template id
    const templateNameMap = new Map<string, string>();
    templates.forEach((t: any) => {
      templateNameMap.set(t.name.toLowerCase().trim(), t.id);
      console.log(`[MIGRATION] Template: "${t.name}" -> ${t.id}`);
    });
    
    // 2. Get all expenses (all months) - this returns the full data
    const allExpenses = await kv.getByPrefix("expense:");
    console.log(`[MIGRATION] Found ${allExpenses.length} total expenses`);
    
    let updated = 0;
    let skipped = 0;
    const updatePromises = [];
    
    // 3. Process each expense
    for (const expense of allExpenses) {
      // Skip if already has groupId
      if (expense.groupId) {
        skipped++;
        continue;
      }
      
      // Try to match expense name with template name
      const expenseName = expense.name.toLowerCase().trim();
      const matchedTemplateId = templateNameMap.get(expenseName);
      
      if (matchedTemplateId && expense.date) {
        // Extract monthKey from date (format: YYYY-MM-DD or YYYY-MM-DDTHH:mm:ss)
        const dateMatch = expense.date.match(/^(\d{4})-(\d{2})/);
        if (dateMatch) {
          const expenseKey = `expense:${dateMatch[1]}-${dateMatch[2]}:${expense.id}`;
          
          console.log(`[MIGRATION] ‚úÖ Updating expense "${expense.name}" (${expense.id}) with groupId: ${matchedTemplateId}`);
          
          const updatedExpense = {
            ...expense,
            groupId: matchedTemplateId
          };
          
          updatePromises.push(kv.set(expenseKey, updatedExpense));
          updated++;
        } else {
          console.warn(`[MIGRATION] ‚ö†Ô∏è Could not parse date for expense ${expense.id}: ${expense.date}`);
          skipped++;
        }
      } else {
        skipped++;
      }
    }
    
    // Execute all updates
    await Promise.all(updatePromises);
    
    console.log(`[MIGRATION] üéâ Complete! Updated: ${updated}, Skipped: ${skipped}`);
    
    return c.json({
      success: true,
      message: `Migration complete: ${updated} expenses updated, ${skipped} skipped`,
      stats: {
        templatesFound: templates.length,
        expensesUpdated: updated,
        expensesSkipped: skipped
      }
    });
  } catch (error: any) {
    console.error('[MIGRATION] ‚ùå Error:', error);
    return c.json({ 
      success: false, 
      error: `Migration failed: ${error.message}` 
    }, 500);
  }
});

// Get exclude state for a specific month
app.get("/make-server-3adbeaf1/exclude-state/:year/:month", async (c) => {
  try {
    const year = c.req.param("year");
    const month = c.req.param("month");
    const key = `exclude-state:${year}-${month}`;
    
    const excludeState = await kv.get(key);
    
    if (!excludeState) {
      return c.json({
        locked: false,
        excludedExpenseIds: [],
        excludedIncomeIds: [],
        isDeductionExcluded: false,
      });
    }
    
    return c.json(excludeState);
  } catch (error: any) {
    console.log(`Error loading exclude state: ${error.message}`);
    return c.json({ error: `Failed to get exclude state: ${error.message}` }, 500);
  }
});

// Save/update exclude state for a specific month
app.post("/make-server-3adbeaf1/exclude-state/:year/:month", async (c) => {
  try {
    const year = c.req.param("year");
    const month = c.req.param("month");
    const key = `exclude-state:${year}-${month}`;
    
    const body = await c.req.json();
    const { locked, excludedExpenseIds, excludedIncomeIds, isDeductionExcluded } = body;
    
    const excludeStateData = {
      locked: Boolean(locked),
      excludedExpenseIds: excludedExpenseIds || [],
      excludedIncomeIds: excludedIncomeIds || [],
      isDeductionExcluded: Boolean(isDeductionExcluded),
      updatedAt: new Date().toISOString(),
    };
    
    await kv.set(key, excludeStateData);
    
    return c.json({ success: true, data: excludeStateData });
  } catch (error: any) {
    return c.json({ error: `Failed to save exclude state: ${error.message}` }, 500);
  }
});

// Delete exclude state lock for specific month
app.delete("/make-server-3adbeaf1/exclude-state/:year/:month", async (c) => {
  try {
    const year = c.req.param("year");
    const month = c.req.param("month");
    const key = `exclude-state:${year}-${month}`;
    
    await kv.del(key);
    
    return c.json({ success: true });
  } catch (error: any) {
    return c.json({ error: `Failed to delete exclude state: ${error.message}` }, 500);
  }
});

// ============================================
// CARRY-OVER SYSTEM - EMERGENCY ENDPOINT
// ============================================

// ‚ö†Ô∏è EMERGENCY USE ONLY - Manual regenerate carry-over
// This endpoint is kept for emergency debugging but removed from UI
// Use case: Fix carry-over data when transactions were migrated cross-month
// Normal flow: Auto-regenerate happens on edit/migration (see PUT expense/income endpoints)
app.post("/make-server-3adbeaf1/carry-over/regenerate/:year/:month", async (c) => {
  try {
    const year = c.req.param("year");
    const month = c.req.param("month");
    const monthKey = `${year}-${month}`;
    
    console.log(`[MANUAL REGENERATE] üîÑ User requested carry-over regeneration for ${monthKey}`);
    
    // Calculate previous month
    const prevMonthKey = getPreviousMonth(monthKey);
    
    console.log(`[MANUAL REGENERATE] Regenerating carry-overs from ${prevMonthKey} ‚Üí ${monthKey}`);
    
    // Regenerate carry-over data
    await generateCarryOversForNextMonth(prevMonthKey);
    
    console.log(`[MANUAL REGENERATE] ‚úÖ Successfully regenerated carry-overs for ${monthKey}`);
    
    // Return new carry-over summary
    const pockets = await getActivePockets();
    const carryOverSummary = [];
    
    for (const pocket of pockets) {
      const carryOver = await getCarryOverForPocket(pocket.id, monthKey);
      carryOverSummary.push({
        pocketId: pocket.id,
        pocketName: pocket.name,
        carryOverAmount: carryOver?.amount || 0,
        fromMonth: prevMonthKey
      });
    }
    
    return c.json({ 
      success: true, 
      message: `Carry-over berhasil dikalkulasi ulang untuk ${formatMonth(monthKey)}`,
      data: {
        monthKey,
        fromMonth: prevMonthKey,
        pockets: carryOverSummary
      }
    });
  } catch (error: any) {
    console.error('[MANUAL REGENERATE] ‚ùå Error:', error);
    return c.json({ error: `Failed to regenerate carry-over: ${error.message}` }, 500);
  }
});

// ============================================
// POCKETS SYSTEM - ENDPOINTS
// ============================================

// Get pockets and balances for a month
app.get("/make-server-3adbeaf1/pockets/:year/:month", async (c) => {
  try {
    const year = c.req.param("year");
    const month = c.req.param("month");
    const monthKey = `${year}-${month}`;
    
    // ‚úÖ FASE 2: Auto-generate carry-over if not exists
    // Check if this is a new month (no carry-over data yet)
    const hasCarryOvers = await checkCarryOverExists(monthKey);
    
    if (!hasCarryOvers) {
      // Calculate previous month
      const prevMonthKey = getPreviousMonth(monthKey);
      
      console.log(`[AUTO-CARRYOVER] First time accessing ${monthKey}, generating carry-overs from ${prevMonthKey}`);
      
      try {
        await generateCarryOversForNextMonth(prevMonthKey);
      } catch (error) {
        console.warn('[AUTO-CARRYOVER] Could not generate carry-overs (maybe first month):', error);
        // Don't fail the whole request if carry-over generation fails
      }
    }
    
    const pockets = await getPockets(monthKey);
    
    // Fetch shared data once instead of per-pocket with individual error handling
    let budget, expensesData, additionalIncome, transfers, excludeState;
    
    try {
      [budget, expensesData, additionalIncome, transfers, excludeState] = await Promise.all([
        kv.get(`budget:${monthKey}`).catch(err => {
          console.warn('[POCKETS] Failed to get budget, using default:', err.message);
          return null;
        }),
        kv.getByPrefix(`expense:${monthKey}:`).catch(err => {
          console.warn('[POCKETS] Failed to get expenses, using empty array:', err.message);
          return [];
        }),
        kv.getByPrefix(`income:${monthKey}:`).catch(err => {
          console.warn('[POCKETS] Failed to get income, using empty array:', err.message);
          return [];
        }),
        kv.getByPrefix(`transfer:${monthKey}:`).catch(err => {
          console.warn('[POCKETS] Failed to get transfers, using empty array:', err.message);
          return [];
        }),
        kv.get(`exclude-state:${monthKey}`).catch(err => {
          console.warn('[POCKETS] Failed to get exclude state, using default:', err.message);
          return null;
        })
      ]);
    } catch (error: any) {
      console.error('[POCKETS] Critical error in Promise.all, using all defaults:', error.message);
      budget = null;
      expensesData = [];
      additionalIncome = [];
      transfers = [];
      excludeState = null;
    }
    
    const sharedData = {
      budget: budget || { initialBudget: 0 },
      expensesData: expensesData || [],
      additionalIncome: additionalIncome || [],
      transfers: transfers || [],
      excludeState: excludeState || { excludedExpenseIds: [], excludedIncomeIds: [] }
    };
    
    // Calculate balances for all pockets using shared data
    const balances = await Promise.all(
      pockets.map(async pocket => {
        // Calculate projected balance (all transactions)
        const projected = await calculatePocketBalance(pocket.id, monthKey, sharedData);
        
        // Calculate realtime balance (transactions up to today)
        const today = new Date();
        today.setHours(23, 59, 59, 999);
        const realtime = await calculatePocketBalance(pocket.id, monthKey, sharedData, today.toISOString());
        
        console.log(`[POCKETS] üéØ Final Balance for ${pocket.name}:`, {
          projected: projected.projectedBalance,
          realtime: realtime.realtimeBalance,
          difference: projected.projectedBalance - realtime.realtimeBalance,
          hasFutureTransactions: projected.projectedBalance !== realtime.realtimeBalance
        });
        
        return {
          ...projected,
          projectedBalance: projected.projectedBalance,  // ‚úÖ Use projected field (not availableBalance!)
          realtimeBalance: realtime.realtimeBalance      // ‚úÖ Use realtime field (FIXED! was using availableBalance)
        };
      })
    );
    
    return c.json({
      success: true,
      data: {
        pockets,
        balances
      }
    });
  } catch (error: any) {
    console.error('[POCKETS] Error in GET /pockets:', error);
    console.error('[POCKETS] Error stack:', error.stack);
    return c.json({ error: `Failed to fetch pockets: ${error.message}` }, 500);
  }
});

// ============================================
// üîç DEBUG ENDPOINT - DEEP DIVE TRANSACTIONS
// ============================================
app.get('/make-server-3adbeaf1/debug-transactions/:year/:month', async (c) => {
  try {
    const year = parseInt(c.req.param('year'));
    const month = parseInt(c.req.param('month'));
    const monthKey = `${year}-${String(month).padStart(2, '0')}`;
    
    // Get all data
    const expensesData = await kv.getByPrefix(`expense:${monthKey}:`).catch(() => []);
    const additionalIncome = await kv.getByPrefix(`income:${monthKey}:`).catch(() => []);
    const transfers = await kv.getByPrefix(`transfer:${monthKey}:`).catch(() => []);
    
    // Get today's date for comparison
    const today = new Date();
    today.setHours(23, 59, 59, 999);
    const todayStr = today.toISOString().split('T')[0];
    
    // Analyze expenses by pocket
    const expensesByPocket: Record<string, any> = {};
    
    for (const expense of expensesData) {
      const pocketId = expense.pocketId;
      if (!expensesByPocket[pocketId]) {
        expensesByPocket[pocketId] = {
          pocketId,
          total: 0,
          count: 0,
          past: { count: 0, total: 0, dates: [] },
          future: { count: 0, total: 0, dates: [] },
          all: []
        };
      }
      
      const expenseDate = new Date(expense.date);
      expenseDate.setHours(0, 0, 0, 0);
      const isPast = expenseDate.getTime() <= today.getTime();
      
      expensesByPocket[pocketId].total += expense.amount;
      expensesByPocket[pocketId].count++;
      expensesByPocket[pocketId].all.push({
        date: expense.date,
        amount: expense.amount,
        description: expense.description,
        isPast
      });
      
      if (isPast) {
        expensesByPocket[pocketId].past.count++;
        expensesByPocket[pocketId].past.total += expense.amount;
        expensesByPocket[pocketId].past.dates.push(expense.date);
      } else {
        expensesByPocket[pocketId].future.count++;
        expensesByPocket[pocketId].future.total += expense.amount;
        expensesByPocket[pocketId].future.dates.push(expense.date);
      }
    }
    
    return c.json({
      success: true,
      data: {
        monthKey,
        today: todayStr,
        summary: {
          totalExpenses: expensesData.length,
          totalIncome: additionalIncome.length,
          totalTransfers: transfers.length
        },
        expensesByPocket,
        debugNote: 'If future.count is 0 for all pockets, then realtime === projected is expected!'
      }
    });
  } catch (error: any) {
    console.error('[DEBUG] Error in debug-transactions:', error);
    return c.json({ error: error.message }, 500);
  }
});

// ============================================
// TIMELINE ENDPOINT - MONTHLY STATEMENT MODEL
// ============================================

/**
 * ‚ö†Ô∏è DEPRECATED ENDPOINT - DO NOT USE!
 * This old endpoint does NOT use auto carry-over system and had bugs:
 * - Bug 1: Used income.description instead of income.name
 * - Bug 2: Used income.amount (USD) instead of income.amountIDR
 * - Bug 3: Manual carry-over calculation instead of using getCarryOverForPocket()
 * 
 * ‚úÖ USE NEW ENDPOINT instead: Line ~2808 (uses generatePocketTimeline)
 * 
 * Kept here for reference only. Route changed to prevent conflicts.
 */
app.get("/make-server-3adbeaf1/timeline-OLD-DEPRECATED/:year/:month/:pocketId", async (c) => {
  try {
    const year = c.req.param("year");
    const month = c.req.param("month");
    const pocketId = c.req.param("pocketId");
    const sortOrder = c.req.query("sortOrder") || "desc"; // desc = newest first
    
    const monthKey = `${year}-${month}`;
    const monthStart = new Date(`${year}-${month}-01T00:00:00.000Z`);
    const monthEnd = new Date(monthStart);
    monthEnd.setMonth(monthEnd.getMonth() + 1); // First day of next month
    
    console.log(`[TIMELINE] Fetching data for pocket ${pocketId}, month ${monthKey}`);
    
    // üîß FIX: Fetch only YEAR-scoped data instead of ALL data to prevent connection timeout
    // Old approach: getByPrefix(`expense:`) fetched EVERYTHING (thousands of records!)
    // New approach: Fetch only current year data (much more efficient)
    
    const currentYear = parseInt(year);
    
    // 1. Fetch expenses for CURRENT YEAR only (not all time!)
    const yearExpenses: any[] = [];
    for (let m = 1; m <= 12; m++) {
      const monthStr = String(m).padStart(2, '0');
      const expensePrefix = `expense:${currentYear}-${monthStr}:`;
      try {
        const monthExpenses = await kv.getByPrefix(expensePrefix);
        yearExpenses.push(...(monthExpenses || []));
      } catch (error: any) {
        console.warn(`[TIMELINE] Failed to get expenses for ${currentYear}-${monthStr}:`, error.message);
      }
    }
    
    const allPocketExpenses = yearExpenses.filter((exp: any) => exp.pocketId === pocketId);
    
    // Filter: Expenses for CURRENT month only
    const currentMonthExpenses = allPocketExpenses.filter((exp: any) => {
      const expDate = new Date(exp.date);
      return expDate >= monthStart && expDate < monthEnd;
    });
    
    // Filter: Expenses BEFORE current month (for Initial Balance calculation)
    const previousExpenses = allPocketExpenses.filter((exp: any) => {
      const expDate = new Date(exp.date);
      return expDate < monthStart;
    });
    
    // 2. Fetch income for CURRENT YEAR only
    const yearIncome: any[] = [];
    for (let m = 1; m <= 12; m++) {
      const monthStr = String(m).padStart(2, '0');
      const incomePrefix = `income:${currentYear}-${monthStr}:`;
      try {
        const monthIncome = await kv.getByPrefix(incomePrefix);
        yearIncome.push(...(monthIncome || []));
      } catch (error: any) {
        console.warn(`[TIMELINE] Failed to get income for ${currentYear}-${monthStr}:`, error.message);
      }
    }
    
    const allPocketIncome = yearIncome.filter((inc: any) => {
      return inc.pocketId === pocketId || inc.targetPocketId === pocketId;
    });
    
    // Filter: Income for CURRENT month only
    const currentMonthIncome = allPocketIncome.filter((inc: any) => {
      const incDate = new Date(inc.date);
      return incDate >= monthStart && incDate < monthEnd;
    });
    
    // Filter: Income BEFORE current month
    const previousIncome = allPocketIncome.filter((inc: any) => {
      const incDate = new Date(inc.date);
      return incDate < monthStart;
    });
    
    // 3. Fetch transfers for CURRENT YEAR only
    const yearTransfers: any[] = [];
    for (let m = 1; m <= 12; m++) {
      const monthStr = String(m).padStart(2, '0');
      const transferPrefix = `transfer:${currentYear}-${monthStr}:`;
      try {
        const monthTransfers = await kv.getByPrefix(transferPrefix);
        yearTransfers.push(...(monthTransfers || []));
      } catch (error: any) {
        console.warn(`[TIMELINE] Failed to get transfers for ${currentYear}-${monthStr}:`, error.message);
      }
    }
    
    const allPocketTransfers = yearTransfers.filter((t: any) => 
      t.fromPocketId === pocketId || t.toPocketId === pocketId
    );
    
    // Filter: Transfers for CURRENT month only
    const currentMonthTransfers = allPocketTransfers.filter((t: any) => {
      const tDate = new Date(t.date);
      return tDate >= monthStart && tDate < monthEnd;
    });
    
    // Filter: Transfers BEFORE current month
    const previousTransfers = allPocketTransfers.filter((t: any) => {
      const tDate = new Date(t.date);
      return tDate < monthStart;
    });
    
    console.log(`[TIMELINE] Current month: ${currentMonthExpenses.length} expenses, ${currentMonthIncome.length} income, ${currentMonthTransfers.length} transfers`);
    console.log(`[TIMELINE] Previous data: ${previousExpenses.length} expenses, ${previousIncome.length} income, ${previousTransfers.length} transfers`);
    
    // 4. Calculate Initial Balance (Saldo Awal)
    // ‚úÖ FIX NOV 10: Use auto-generated carry-over data instead of manual calculation
    // This ensures consistency with the carry-over system
    let initialBalance = 0;
    
    // ‚úÖ FIX: Use constant from POCKET_IDS (pocket_daily), not hardcoded 'pocket_sehari_hari'!
    if (pocketId === POCKET_IDS.DAILY) {
      // ‚úÖ SEHARI-HARI: Budget Awal + Carry-over
      // This pocket is funded by monthly budget allocation
      
      // Fetch budget data for current month
      const budgetKey = `budget:${monthKey}`;
      console.log(`[TIMELINE DEBUG] Fetching budget with key: "${budgetKey}"`);
      
      let budgetData = null;
      try {
        budgetData = await kv.get(budgetKey);
        console.log(`[TIMELINE DEBUG] budgetData raw:`, JSON.stringify(budgetData, null, 2));
      } catch (error: any) {
        console.warn(`[TIMELINE] Failed to get budget for ${monthKey}:`, error.message);
      }
      
      // ‚ö†Ô∏è CRITICAL: budgetData could be null if budget hasn't been set for this month
      // In that case, budgetAwal = 0 is correct (no budget allocated yet)
      const budgetAwal = budgetData?.initialBudget || 0;
      console.log(`[TIMELINE DEBUG] budgetAwal extracted: ${budgetAwal}`);
      
      // ‚úÖ NEW: Use auto-generated carry-over data (consistent with carry-over system)
      let carryOver = null;
      try {
        carryOver = await getCarryOverForPocket(pocketId, monthKey);
      } catch (error) {
        console.warn('[TIMELINE] Error fetching carry-over:', error);
      }
      const carryoverFromPrevious = carryOver?.amount || 0;
      
      // Initial Balance = Budget Awal (this month) + Carry-over from previous
      initialBalance = budgetAwal + carryoverFromPrevious;
      
      console.log(`[TIMELINE] üè¶ Sehari-hari Special Logic:`);
      console.log(`  - Month: ${monthKey}`);
      console.log(`  - Budget Key: "${budgetKey}"`);
      console.log(`  - Budget Data Found: ${budgetData ? 'YES' : 'NO'}`);
      console.log(`  - Budget Awal (${monthKey}): ${budgetAwal}`);
      console.log(`  - Carry-over from auto-generated data: ${carryoverFromPrevious}`);
      console.log(`  - Carry-over breakdown:`, carryOver?.breakdown);
      console.log(`  - Initial Balance (FINAL): ${initialBalance}`);
      
    } else {
      // ‚úÖ OTHER POCKETS: Only carry-over
      // Uang Dingin, Custom pockets are income-driven, not budget-driven
      
      // ‚úÖ NEW: Use auto-generated carry-over data
      let carryOver = null;
      try {
        carryOver = await getCarryOverForPocket(pocketId, monthKey);
      } catch (error) {
        console.warn('[TIMELINE] Error fetching carry-over:', error);
      }
      initialBalance = carryOver?.amount || 0;
      
      console.log(`[TIMELINE] ${pocketId} - Carry-over only: ${initialBalance}`);
      console.log(`  - Carry-over breakdown:`, carryOver?.breakdown);
    }
    
    // 5. Build timeline entries for CURRENT month ONLY
    const entries: TimelineEntry[] = [];
    
    // Add current month expenses
    currentMonthExpenses.forEach((expense: any) => {
      entries.push({
        id: expense.id,
        type: 'expense',
        date: expense.date,
        description: expense.name,
        amount: -expense.amount, // Negative for expense
        balanceAfter: 0, // Will be calculated later
        icon: expense.icon || 'üí∏',
        color: expense.color || 'red',
        metadata: { 
          ...expense,
          category: expense.category
        }
      });
    });
    
    // Add current month income
    currentMonthIncome.forEach((income: any) => {
      entries.push({
        id: income.id,
        type: 'income',
        date: income.date,
        description: income.name || 'Pemasukan',  // ‚úÖ FIX: Use income.name (not description)
        amount: (income.amountIDR || income.amount) - (income.deduction || 0), // ‚úÖ FIX: Use amountIDR (not amount/USD)
        balanceAfter: 0, // Will be calculated later
        icon: 'üí∞',
        color: 'green',
        metadata: { 
          ...income,
          amountUSD: income.amountUSD || income.amount,
          exchangeRate: income.exchangeRate,
          deduction: income.deduction
        }
      });
    });
    
    // Add current month transfers
    currentMonthTransfers.forEach((transfer: any) => {
      const isIncoming = transfer.toPocketId === pocketId;
      entries.push({
        id: transfer.id,
        type: 'transfer',
        date: transfer.date,
        description: isIncoming 
          ? `Transfer dari ${transfer.fromPocketName || 'Unknown'}`
          : `Transfer ke ${transfer.toPocketName || 'Unknown'}`,
        amount: isIncoming ? transfer.amount : -transfer.amount,
        balanceAfter: 0, // Will be calculated later
        icon: isIncoming ? '‚¨ÖÔ∏è' : '‚û°Ô∏è',
        color: isIncoming ? 'green' : 'blue',
        metadata: { 
          ...transfer,
          direction: isIncoming ? 'in' : 'out'
        }
      });
    });
    
    // 6. Sort entries by date
    entries.sort((a, b) => {
      const dateA = new Date(a.date).getTime();
      const dateB = new Date(b.date).getTime();
      return sortOrder === 'desc' ? dateB - dateA : dateA - dateB;
    });
    
    console.log(`[TIMELINE] Total entries for ${monthKey}: ${entries.length}`);
    
    // 7. Calculate balanceAfter for each entry (cumulative from initialBalance)
    let runningBalance = initialBalance; // ‚úÖ Start from carry-over!
    
    // Start from oldest (end of sorted DESC array)
    if (sortOrder === 'desc') {
      // Process in reverse to calculate cumulative balance from oldest to newest
      for (let i = entries.length - 1; i >= 0; i--) {
        runningBalance += entries[i].amount;
        entries[i].balanceAfter = runningBalance;
      }
    } else {
      // Process forward for ASC
      for (let i = 0; i < entries.length; i++) {
        runningBalance += entries[i].amount;
        entries[i].balanceAfter = runningBalance;
      }
    }
    
    // 8. Add Initial Balance entry (Saldo Awal) at the beginning of month
    const initialBalanceEntry = {
      id: 'initial_balance',
      type: 'initial_balance' as const,
      date: monthStart.toISOString(),
      description: 'Saldo Awal',
      amount: initialBalance,
      balanceAfter: initialBalance,
      icon: 'üè¶',
      color: 'blue',
      metadata: { 
        isInitialBalance: true,
        fromPreviousMonths: true,
        monthKey: monthKey
      }
    };
    
    // Add to end of array (will be displayed first after sorting DESC)
    entries.push(initialBalanceEntry);
    
    console.log(`[TIMELINE] Month ${monthKey} - Initial Balance: ${initialBalance}, Final Balance: ${runningBalance}`);
    
    return c.json({
      success: true,
      data: {
        entries,
        count: entries.length,
        monthKey,
        initialBalance,
        finalBalance: runningBalance,
        monthStart: monthStart.toISOString(),
        monthEnd: monthEnd.toISOString()
      }
    });
  } catch (error: any) {
    console.error('[TIMELINE] Error:', error);
    console.error('[TIMELINE] Stack:', error.stack);
    return c.json({ 
      success: false, 
      error: `Failed to fetch timeline: ${error.message}` 
    }, 500);
  }
});

// Create custom pocket
app.post("/make-server-3adbeaf1/pockets/:year/:month", async (c) => {
  try {
    const year = c.req.param("year");
    const month = c.req.param("month");
    const monthKey = `${year}-${month}`;
    const body = await c.req.json();
    const { name, description, icon, color, enableWishlist } = body;
    
    if (!name) {
      return c.json({ 
        success: false, 
        error: 'Pocket name is required' 
      }, 400);
    }
    
    // Get existing pockets to determine order
    const existingPockets = await getPockets(monthKey);
    const maxOrder = existingPockets.length > 0 
      ? Math.max(...existingPockets.map((p: Pocket) => p.order))
      : 0;
    
    // Create new pocket
    const newPocket: Pocket = {
      id: `pocket_custom_${Date.now()}_${crypto.randomUUID().substring(0, 8)}`,
      name,
      type: 'custom',
      description,
      icon: icon || 'Wallet',
      color: color || 'blue',
      order: maxOrder + 1,
      createdAt: new Date().toISOString(),
      status: 'active', // ‚úÖ FASE 1: Explicit status
      enableWishlist: enableWishlist !== undefined ? enableWishlist : true // Default true for custom pockets
    };
    
    // ‚úÖ FASE 1: Save to global registry (not per-month)
    await createGlobalPocket(newPocket);
    
    return c.json({
      success: true,
      data: newPocket
    });
  } catch (error: any) {
    return c.json({ success: false, error: error.message }, 500);
  }
});

// Update pocket wishlist setting
app.put("/make-server-3adbeaf1/pockets/:year/:month/:pocketId/wishlist-setting", async (c) => {
  try {
    const pocketId = c.req.param("pocketId");
    const year = c.req.param("year");
    const month = c.req.param("month");
    const monthKey = `${year}-${month}`;
    const body = await c.req.json();
    const { enableWishlist } = body;
    
    if (!pocketId) {
      return c.json({ 
        success: false, 
        error: 'Pocket ID is required' 
      }, 400);
    }
    
    if (enableWishlist === undefined) {
      return c.json({ 
        success: false, 
        error: 'enableWishlist is required' 
      }, 400);
    }
    
    // ‚úÖ FASE 1: Update in global registry
    try {
      const updatedPocket = await updateGlobalPocket(pocketId, {
        enableWishlist: Boolean(enableWishlist)
      });
      
      return c.json({
        success: true,
        data: updatedPocket
      });
    } catch (error: any) {
      return c.json({ 
        success: false, 
        error: error.message 
      }, 404);
    }
  } catch (error: any) {
    return c.json({ success: false, error: error.message }, 500);
  }
});

// ‚úÖ FASE 1: Update pocket (general updates - name, icon, color, etc.)
app.put("/make-server-3adbeaf1/pockets/:year/:month/:pocketId", async (c) => {
  try {
    const pocketId = c.req.param("pocketId");
    const body = await c.req.json();
    
    if (!pocketId) {
      return c.json({ 
        success: false, 
        error: 'Pocket ID is required' 
      }, 400);
    }
    
    // ‚úÖ FASE 1: Update in global registry
    try {
      const updatedPocket = await updateGlobalPocket(pocketId, body);
      
      return c.json({
        success: true,
        data: updatedPocket
      });
    } catch (error: any) {
      return c.json({ 
        success: false, 
        error: error.message 
      }, 404);
    }
  } catch (error: any) {
    return c.json({ success: false, error: error.message }, 500);
  }
});

// ‚úÖ FASE 1: Delete pocket (soft delete - archive)
app.delete("/make-server-3adbeaf1/pockets/:year/:month/:pocketId", async (c) => {
  try {
    const pocketId = c.req.param("pocketId");
    
    // Prevent deletion of default pockets
    if (pocketId === POCKET_IDS.DAILY || pocketId === POCKET_IDS.COLD_MONEY) {
      return c.json({ 
        success: false, 
        error: 'Cannot delete default pockets' 
      }, 400);
    }
    
    // ‚úÖ FASE 1: Soft delete (archive) in global registry
    try {
      await archivePocket(pocketId);
      
      return c.json({
        success: true,
        message: 'Pocket archived successfully'
      });
    } catch (error: any) {
      return c.json({ 
        success: false, 
        error: error.message 
      }, 404);
    }
  } catch (error: any) {
    return c.json({ success: false, error: error.message }, 500);
  }
});

// ‚úÖ FASE 2: Manual trigger for carry-over generation
app.post("/make-server-3adbeaf1/carryover/generate/:year/:month", async (c) => {
  try {
    const year = c.req.param("year");
    const month = c.req.param("month");
    const monthKey = `${year}-${month}`;
    
    console.log(`[MANUAL-CARRYOVER] Manual trigger for ${monthKey}`);
    
    await generateCarryOversForNextMonth(monthKey);
    
    return c.json({
      success: true,
      message: `Carry-overs generated for next month after ${monthKey}`
    });
  } catch (error: any) {
    console.error('[MANUAL-CARRYOVER] Error:', error);
    return c.json({ success: false, error: error.message }, 500);
  }
});

// Create transfer between pockets
app.post("/make-server-3adbeaf1/transfer/:year/:month", async (c) => {
  try {
    const year = c.req.param("year");
    const month = c.req.param("month");
    const monthKey = `${year}-${month}`;
    const body = await c.req.json();
    const { fromPocketId, toPocketId, amount, date, note } = body;
    
    if (!fromPocketId || !toPocketId || !amount) {
      return c.json({ 
        success: false, 
        error: 'Missing required fields' 
      }, 400);
    }
    
    // Get current balance
    const fromBalance = await calculatePocketBalance(fromPocketId, monthKey);
    
    // Validate transfer
    const validation = validateTransfer(
      { fromPocketId, toPocketId, amount },
      fromBalance
    );
    
    if (!validation.valid) {
      return c.json({ 
        success: false, 
        error: validation.error 
      }, 400);
    }
    
    // Get pockets to preserve pocket names for history (in case pocket gets deleted later)
    const pockets = await getPockets(monthKey);
    const fromPocket = pockets.find((p: Pocket) => p.id === fromPocketId);
    const toPocket = pockets.find((p: Pocket) => p.id === toPocketId);
    
    // Create transfer
    const transferId = `transfer_${Date.now()}_${crypto.randomUUID().substring(0, 8)}`;
    
    // CRITICAL FIX: Parse date to use UTC noon standard to avoid timezone issues
    let transferDate;
    if (date) {
      if (date.includes('T')) {
        transferDate = date;
      } else {
        // Just a date (YYYY-MM-DD), use noon UTC
        transferDate = `${date}T12:00:00.000Z`;
      }
    } else {
      transferDate = new Date().toISOString();
    }
    
    const transfer: TransferTransaction = {
      id: transferId,
      type: 'transfer',
      amount: Number(amount),
      fromPocketId,
      toPocketId,
      fromPocketName: fromPocket?.name, // Preserve name for history
      toPocketName: toPocket?.name,     // Preserve name for history
      date: transferDate,
      note,
      createdAt: new Date().toISOString()
    };
    
    // Save to KV using prefix pattern (FIXED)
    const transferKey = `transfer:${monthKey}:${transferId}`;
    await kv.set(transferKey, transfer);
    
    // Recalculate balances
    const updatedFromBalance = await calculatePocketBalance(fromPocketId, monthKey);
    const updatedToBalance = await calculatePocketBalance(toPocketId, monthKey);
    
    return c.json({
      success: true,
      data: {
        transfer,
        updatedBalances: {
          [fromPocketId]: updatedFromBalance,
          [toPocketId]: updatedToBalance
        }
      }
    });
  } catch (error: any) {
    return c.json({ success: false, error: error.message }, 500);
  }
});

// Delete transfer
app.delete("/make-server-3adbeaf1/transfer/:year/:month/:id", async (c) => {
  try {
    const year = c.req.param("year");
    const month = c.req.param("month");
    const transferId = c.req.param("id");
    const monthKey = `${year}-${month}`;
    
    if (!transferId) {
      return c.json({ success: false, error: 'Missing transfer ID' }, 400);
    }
    
    // Get transfer using prefix pattern (FIXED)
    const transferKey = `transfer:${monthKey}:${transferId}`;
    const transferToDelete = await kv.get(transferKey);
    
    if (!transferToDelete) {
      return c.json({ success: false, error: 'Transfer not found' }, 404);
    }
    
    // Delete transfer
    await kv.del(transferKey);
    
    // Recalculate balances
    const updatedFromBalance = await calculatePocketBalance(transferToDelete.fromPocketId, monthKey);
    const updatedToBalance = await calculatePocketBalance(transferToDelete.toPocketId, monthKey);
    
    return c.json({
      success: true,
      data: {
        deletedId: transferId,
        updatedBalances: {
          [transferToDelete.fromPocketId]: updatedFromBalance,
          [transferToDelete.toPocketId]: updatedToBalance
        }
      }
    });
  } catch (error: any) {
    return c.json({ success: false, error: error.message }, 500);
  }
});

// Get timeline for a pocket
app.get("/make-server-3adbeaf1/timeline/:year/:month/:pocketId", async (c) => {
  try {
    const year = c.req.param("year");
    const month = c.req.param("month");
    const pocketId = c.req.param("pocketId");
    const monthKey = `${year}-${month}`;
    const sortOrder = (c.req.query('sortOrder') || 'desc') as 'asc' | 'desc';
    
    if (!pocketId) {
      return c.json({ success: false, error: 'Missing pocket ID' }, 400);
    }
    
    // ‚úÖ FASE 3: Fetch shared data (removed old carryOvers fetch)
    const [budget, expenses, additionalIncome, transfers, excludeState, pockets] = await Promise.all([
      kv.get(`budget:${monthKey}`),
      kv.getByPrefix(`expense:${monthKey}:`),
      kv.getByPrefix(`income:${monthKey}:`),
      kv.getByPrefix(`transfer:${monthKey}:`),
      kv.get(`exclude-state:${monthKey}`),
      getPockets(monthKey)
    ]);
    
    const sharedData = {
      budget: budget || { initialBudget: 0 },
      expenses: expenses || [],
      additionalIncome: additionalIncome || [],
      transfers: transfers || [],
      excludeState: excludeState || { excludedExpenseIds: [], excludedIncomeIds: [] },
      pockets
      // ‚úÖ FASE 3: No longer passing carryOvers - fetched individually in generatePocketTimeline
    };
    
    // ‚úÖ FASE 3: Generate timeline with shared data (now async!)
    const entries = await generatePocketTimeline(pocketId, monthKey, sortOrder, sharedData);
    
    // Calculate summary
    const summary = {
      totalIncome: entries.filter(e => e.type === 'income').reduce((sum, e) => sum + e.amount, 0),
      totalExpense: Math.abs(entries.filter(e => e.type === 'expense').reduce((sum, e) => sum + e.amount, 0)),
      netTransfer: entries.filter(e => e.type === 'transfer').reduce((sum, e) => sum + e.amount, 0),
      finalBalance: entries.length > 0 ? entries[0].balanceAfter : 0
    };
    
    return c.json({
      success: true,
      data: { entries, summary }
    });
  } catch (error: any) {
    console.error('[TIMELINE] Error in GET /timeline:', error);
    console.error('[TIMELINE] Error stack:', error.stack);
    return c.json({ success: false, error: error.message }, 500);
  }
});

// ============================================
// EXPENSES AGGREGATION ENDPOINT (for CategoryBreakdown MoM)
// ============================================

// Get all expenses for a month (across all pockets) - for MoM comparison
app.get("/make-server-3adbeaf1/expenses/:year/:month", async (c) => {
  // üî• CRITICAL: Force logging to ensure endpoint is hit
  console.log(`\n\nüî•üî•üî• [EXPENSES ENDPOINT HIT] üî•üî•üî•`);
  console.log(`[EXPENSES ENDPOINT] URL: ${c.req.url}`);
  console.log(`[EXPENSES ENDPOINT] Method: ${c.req.method}`);
  console.log(`[EXPENSES ENDPOINT] Time: ${new Date().toISOString()}`);
  
  try {
    const year = c.req.param("year");
    const month = c.req.param("month");
    const monthKey = `${year}-${month}`;
    
    console.log(`üìä [Expenses Endpoint] ============ START DEBUG ============`);
    console.log(`üìä [Expenses Endpoint] Request params:`, { year, month, monthKey });
    console.log(`üìä [Expenses Endpoint] Query prefix: expense:${monthKey}:`);
    
    // Fetch all expenses for the month
    const expenses = await kv.getByPrefix(`expense:${monthKey}:`);
    
    console.log(`üìä [Expenses Endpoint] Raw result:`, {
      isNull: expenses === null,
      isUndefined: expenses === undefined,
      isArray: Array.isArray(expenses),
      length: expenses?.length || 0,
      type: typeof expenses
    });
    
    if (!expenses || expenses.length === 0) {
      console.log(`‚ö†Ô∏è [Expenses Endpoint] No expenses found for ${monthKey}`);
      
      // üîç DEBUG: Check if data exists with different format
      console.log(`üîç [DEBUG] Checking alternate key formats...`);
      const altFormat1 = await kv.getByPrefix(`expense:${month}-${year}:`); // MM-YYYY
      const altFormat2 = await kv.getByPrefix(`expense:${year}${month}:`); // YYYYMM
      const altFormat3 = await kv.getByPrefix(`expense:${year}-${month.padStart(2, '0')}:`); // YYYY-MM (with leading zero)
      
      console.log(`üîç [DEBUG] Alt format 1 (${month}-${year}):`, altFormat1?.length || 0);
      console.log(`üîç [DEBUG] Alt format 2 (${year}${month}):`, altFormat2?.length || 0);
      console.log(`üîç [DEBUG] Alt format 3 (${year}-${month.padStart(2, '0')}):`, altFormat3?.length || 0);
      
      // üîç CRITICAL: Log first result from each format to see actual key structure
      if (altFormat1?.length > 0) {
        console.log(`üîç [DEBUG] Sample alt1:`, altFormat1[0]);
      }
      if (altFormat2?.length > 0) {
        console.log(`üîç [DEBUG] Sample alt2:`, altFormat2[0]);
      }
      if (altFormat3?.length > 0) {
        console.log(`üîç [DEBUG] Sample alt3:`, altFormat3[0]);
      }
      
      // Try alternate format 3 (with leading zero)
      if (altFormat3 && altFormat3.length > 0) {
        console.log(`‚úÖ [Expenses Endpoint] Using alternate format 3 (${altFormat3.length} expenses)`);
        return c.json({
          success: true,
          data: altFormat3,
          debug: {
            usedFormat: `expense:${year}-${month.padStart(2, '0')}:`,
            originalFormat: `expense:${monthKey}:`
          }
        });
      }
      
      return c.json({
        success: true,
        data: [],
        debug: {
          queriedKey: `expense:${monthKey}:`,
          alternateFormats: {
            'MM-YYYY': altFormat1?.length || 0,
            'YYYYMM': altFormat2?.length || 0,
            'YYYY-MM': altFormat3?.length || 0
          }
        }
      });
    }
    
    console.log(`‚úÖ [Expenses Endpoint] Found ${expenses.length} expenses for ${monthKey}`);
    console.log(`‚úÖ [Expenses Endpoint] First 3 expenses:`, 
      expenses.slice(0, 3).map((e: any) => ({
        id: e.id,
        name: e.name,
        date: e.date,
        amount: e.amount,
        category: e.category,
        hasItems: !!(e.items && e.items.length > 0),
        itemCount: e.items?.length || 0
      }))
    );
    console.log(`üìä [Expenses Endpoint] ============ END DEBUG ============`);
    
    return c.json({
      success: true,
      data: expenses
    });
  } catch (error: any) {
    console.error(`‚ùå [Expenses Endpoint] Error:`, error);
    return c.json({ success: false, error: error.message }, 500);
  }
});

// üîç DEBUG HELPER: List all expense keys for a specific prefix (for debugging)
app.get("/make-server-3adbeaf1/debug/keys", async (c) => {
  try {
    const prefix = c.req.query('prefix') || 'expense:2025-';
    
    console.log(`üîç [Debug Keys] Listing all keys with prefix: ${prefix}`);
    
    const results = await kv.getByPrefix(prefix);
    
    console.log(`üîç [Debug Keys] Found ${results?.length || 0} keys`);
    
    return c.json({
      success: true,
      prefix,
      count: results?.length || 0,
      keys: results?.slice(0, 20).map((item: any) => ({
        id: item.id,
        date: item.date,
        name: item.name,
        amount: item.amount,
        category: item.category,
        pocketId: item.pocketId,
        items: item.items || undefined  // üîç DEBUG: Include items to check template structure
      })) || [],
      message: results?.length > 20 ? `Showing first 20 of ${results.length} results` : undefined
    });
  } catch (error: any) {
    console.error(`‚ùå [Debug Keys] Error:`, error);
    return c.json({ success: false, error: error.message }, 500);
  }
});

// ============================================
// CARRY OVER ENDPOINTS
// ============================================

// Get carry overs for a month
app.get("/make-server-3adbeaf1/carryover/:year/:month", async (c) => {
  try {
    const year = c.req.param("year");
    const month = c.req.param("month");
    const monthKey = `${year}-${month}`;
    
    // ‚úÖ FASE 2: Fetch NEW carry-over format (per pocket)
    const pockets = await getActivePockets();
    const carryOverPromises = pockets.map(p => getCarryOverForPocket(p.id, monthKey));
    const carryOverResults = await Promise.all(carryOverPromises);
    const carryOvers = carryOverResults.filter(co => co !== null) as CarryOverEntry[];
    
    // Build summary
    const summary: CarryOverSummary = {
      monthKey,
      pockets: carryOvers.map((co: CarryOverEntry) => {
        const pocket = pockets.find((p: Pocket) => p.id === co.pocketId);
        return {
          pocketId: co.pocketId,
          pocketName: pocket?.name || 'Unknown',
          carryOverAmount: co.amount,
          hasCarryOver: co.amount !== 0,
          fromMonth: co.fromMonth
        };
      }),
      totalCarryOver: carryOvers.reduce((sum: number, co: CarryOverEntry) => sum + co.amount, 0)
    };
    
    return c.json({
      success: true,
      data: {
        carryOvers,
        summary
      }
    });
  } catch (error: any) {
    console.error('[CARRYOVER/GET] Error:', error);
    return c.json({ success: false, error: error.message }, 500);
  }
});

// Generate carry overs manually (for recalculation)
app.post("/make-server-3adbeaf1/carryover/generate", async (c) => {
  try {
    const body = await c.req.json();
    const { fromMonth, toMonth } = body;
    
    if (!fromMonth || !toMonth) {
      return c.json({ 
        success: false, 
        error: 'Missing fromMonth or toMonth' 
      }, 400);
    }
    
    // ‚úÖ FASE 2: Use NEW carry-over generation function
    await generateCarryOversForNextMonth(fromMonth);
    
    // Fetch the generated carry-overs to return
    const pockets = await getActivePockets();
    const carryOvers = await Promise.all(
      pockets.map(p => getCarryOverForPocket(p.id, toMonth))
    );
    
    return c.json({
      success: true,
      data: {
        generated: carryOvers.filter(co => co !== null),
        message: `Generated ${carryOvers.filter(co => co !== null).length} carry over entries from ${fromMonth} to ${toMonth}`
      }
    });
  } catch (error: any) {
    console.error('[CARRYOVER/GENERATE] Error:', error);
    return c.json({ success: false, error: error.message }, 500);
  }
});

// Recalculate carry over for a month (if past month changed)
app.put("/make-server-3adbeaf1/carryover/recalculate/:year/:month", async (c) => {
  try {
    const year = c.req.param("year");
    const month = c.req.param("month");
    const monthKey = `${year}-${month}`;
    const prevMonth = getPreviousMonth(monthKey);
    
    // ‚úÖ FASE 2: Delete existing NEW carry-over entries (per pocket)
    const pockets = await getActivePockets();
    await Promise.all(
      pockets.map(p => kv.del(`carryover:${monthKey}:${p.id}`))
    );
    
    // Regenerate using NEW function
    await generateCarryOversForNextMonth(prevMonth);
    
    // Fetch newly generated carry-overs
    const carryOvers = await Promise.all(
      pockets.map(p => getCarryOverForPocket(p.id, monthKey))
    );
    
    return c.json({
      success: true,
      data: {
        updated: carryOvers.filter(co => co !== null),
        message: `Recalculated carry overs for ${monthKey}`
      }
    });
  } catch (error: any) {
    console.error('[CARRYOVER/RECALCULATE] Error:', error);
    return c.json({ success: false, error: error.message }, 500);
  }
});

// Get carry over history for a pocket (last N months)
app.get("/make-server-3adbeaf1/carryover/history/:pocketId", async (c) => {
  try {
    const pocketId = c.req.param("pocketId");
    const limit = parseInt(c.req.query('limit') || '12');
    
    // This would require iterating through months
    // For now, return placeholder
    // TODO: Implement proper history tracking
    
    return c.json({
      success: true,
      data: {
        history: [],
        message: 'History endpoint - not fully implemented yet'
      }
    });
  } catch (error) {
    console.log(`Error fetching carry over history: ${error}`);
    return c.json({ success: false, error: error.message }, 500);
  }
});

// ============================================
// TRANSFER ENDPOINTS
// ============================================

// Transfer between pockets
app.post("/make-server-3adbeaf1/transfers/:year/:month", async (c) => {
  try {
    const year = c.req.param("year");
    const month = c.req.param("month");
    const monthKey = `${year}-${month}`;
    const body = await c.req.json();
    
    const { fromPocketId, toPocketId, amount, date, note } = body;
    
    if (!fromPocketId || !toPocketId || !amount) {
      return c.json({ 
        success: false, 
        error: "fromPocketId, toPocketId, and amount are required" 
      }, 400);
    }
    
    if (fromPocketId === toPocketId) {
      return c.json({ 
        success: false, 
        error: "Cannot transfer to the same pocket" 
      }, 400);
    }
    
    if (amount <= 0) {
      return c.json({ 
        success: false, 
        error: "Transfer amount must be positive" 
      }, 400);
    }
    
    console.log(`[Transfer] ${fromPocketId} ‚Üí ${toPocketId}: ${amount} on ${date}`);
    
    // Parse date: if date is in YYYY-MM-DD format, add time at noon
    let transferDate;
    if (date) {
      if (date.includes('T')) {
        transferDate = date;
      } else {
        // Use noon (12:00 UTC) to avoid timezone issues
        transferDate = `${date}T12:00:00.000Z`;
      }
    } else {
      transferDate = new Date().toISOString();
    }
    
    // Create transfer record
    const transferId = crypto.randomUUID();
    const transfer = {
      id: transferId,
      fromPocketId,
      toPocketId,
      amount: Number(amount),
      date: transferDate,
      note: note || null,
      createdAt: new Date().toISOString()
    };
    
    // Save transfer
    const transferKey = `transfer:${monthKey}:${transferId}`;
    await kv.set(transferKey, transfer);
    
    console.log(`[Transfer] Saved: ${transferKey}`);
    
    return c.json({
      success: true,
      data: transfer
    });
  } catch (error: any) {
    console.error(`[Transfer Error]`, error);
    return c.json({ 
      success: false, 
      error: `Failed to create transfer: ${error.message}` 
    }, 500);
  }
});

// Get all transfers for a month
app.get("/make-server-3adbeaf1/transfers/:year/:month", async (c) => {
  try {
    const year = c.req.param("year");
    const month = c.req.param("month");
    const monthKey = `${year}-${month}`;
    
    const transferKeys = await kv.getByPrefix(`transfer:${monthKey}:`);
    const transfers = transferKeys || [];
    
    return c.json({
      success: true,
      data: transfers
    });
  } catch (error: any) {
    return c.json({ 
      success: false, 
      error: `Failed to fetch transfers: ${error.message}` 
    }, 500);
  }
});

// Delete transfer
app.delete("/make-server-3adbeaf1/transfers/:year/:month/:id", async (c) => {
  try {
    const year = c.req.param("year");
    const month = c.req.param("month");
    const id = c.req.param("id");
    const monthKey = `${year}-${month}`;
    const transferKey = `transfer:${monthKey}:${id}`;
    
    await kv.del(transferKey);
    
    return c.json({
      success: true,
      message: "Transfer deleted successfully"
    });
  } catch (error: any) {
    return c.json({ 
      success: false, 
      error: `Failed to delete transfer: ${error.message}` 
    }, 500);
  }
});

// ============================================
// SMART SUGGESTIONS ENDPOINTS
// ============================================

// Get smart suggestions for a month
app.get("/make-server-3adbeaf1/suggestions/:year/:month", async (c) => {
  try {
    const year = c.req.param("year");
    const month = c.req.param("month");
    const monthKey = `${year}-${month}`;
    
    const suggestions = await generateSuggestions(monthKey);
    
    // Sort by priority
    const priorityOrder = { high: 0, medium: 1, low: 2 };
    suggestions.sort((a, b) => priorityOrder[a.priority] - priorityOrder[b.priority]);
    
    return c.json({
      success: true,
      data: {
        suggestions,
        count: suggestions.length,
        byPriority: {
          high: suggestions.filter(s => s.priority === 'high').length,
          medium: suggestions.filter(s => s.priority === 'medium').length,
          low: suggestions.filter(s => s.priority === 'low').length
        }
      }
    });
  } catch (error) {
    console.log(`Error generating suggestions: ${error}`);
    return c.json({ success: false, error: error.message }, 500);
  }
});

// Get budget health score
app.get("/make-server-3adbeaf1/health/:year/:month", async (c) => {
  try {
    const year = c.req.param("year");
    const month = c.req.param("month");
    const monthKey = `${year}-${month}`;
    
    const health = await calculateBudgetHealth(monthKey);
    
    return c.json({
      success: true,
      data: health
    });
  } catch (error) {
    console.log(`Error calculating budget health: ${error}`);
    return c.json({ success: false, error: error.message }, 500);
  }
});

// ============================================
// POCKETS UPDATE ENDPOINT
// ============================================

// Update pocket (name, icon, description, etc.)
app.put("/make-server-3adbeaf1/pockets/:year/:month/update", async (c) => {
  try {
    const year = c.req.param("year");
    const month = c.req.param("month");
    const monthKey = `${year}-${month}`;
    const body = await c.req.json();
    const { pocketId, updates } = body;
    
    if (!pocketId) {
      return c.json({ 
        success: false, 
        error: 'Missing pocketId' 
      }, 400);
    }
    
    if (!updates || typeof updates !== 'object') {
      return c.json({ 
        success: false, 
        error: 'Missing updates object' 
      }, 400);
    }
    
    // Get pockets for this month
    const pocketsKey = `pockets:${monthKey}`;
    const allPockets = await kv.get(pocketsKey) || [...DEFAULT_POCKETS];
    
    // Find pocket to update
    const pocketIndex = allPockets.findIndex((p: Pocket) => p.id === pocketId);
    
    if (pocketIndex === -1) {
      return c.json({ 
        success: false, 
        error: 'Pocket not found' 
      }, 404);
    }
    
    const pocket = allPockets[pocketIndex];
    
    // Validate: cannot change type of primary pockets
    if (pocket.type === 'primary' && updates.type && updates.type !== 'primary') {
      return c.json({ 
        success: false, 
        error: 'Cannot change type of primary pockets' 
      }, 400);
    }
    
    // Allow updating: name, icon, description, color (for custom pockets)
    // For primary pockets, only allow name, icon, description
    const allowedUpdates: Partial<Pocket> = {};
    
    if (updates.name !== undefined) {
      allowedUpdates.name = updates.name;
    }
    
    if (updates.icon !== undefined) {
      allowedUpdates.icon = updates.icon;
    }
    
    if (updates.description !== undefined) {
      allowedUpdates.description = updates.description;
    }
    
    // Color can only be updated for custom pockets
    if (pocket.type === 'custom' && updates.color !== undefined) {
      allowedUpdates.color = updates.color;
    }
    
    // Update the pocket
    allPockets[pocketIndex] = {
      ...pocket,
      ...allowedUpdates
    };
    
    // Save back
    await kv.set(pocketsKey, allPockets);
    
    return c.json({
      success: true,
      data: allPockets[pocketIndex]
    });
  } catch (error: any) {
    console.log(`Error updating pocket: ${error}`);
    return c.json({ 
      success: false, 
      error: error.message 
    }, 500);
  }
});

// ============================================
// ARCHIVE ENDPOINTS
// ============================================

// Archive a pocket (balance must be 0)
app.post("/make-server-3adbeaf1/pockets/:year/:month/archive", async (c) => {
  try {
    const year = c.req.param("year");
    const month = c.req.param("month");
    const monthKey = `${year}-${month}`;
    const body = await c.req.json();
    const { pocketId, reason } = body;
    
    if (!pocketId) {
      return c.json({ 
        success: false, 
        error: 'Missing pocketId' 
      }, 400);
    }
    
    const result = await archivePocket({
      pocketId,
      monthKey,
      reason
    });
    
    return c.json({
      success: true,
      data: result
    });
  } catch (error) {
    console.log(`Error archiving pocket: ${error}`);
    return c.json({ 
      success: false, 
      error: error.message 
    }, 400);
  }
});

// Unarchive a pocket (restore)
app.post("/make-server-3adbeaf1/unarchive/:year/:month", async (c) => {
  try {
    const year = c.req.param("year");
    const month = c.req.param("month");
    const monthKey = `${year}-${month}`;
    const body = await c.req.json();
    const { pocketId } = body;
    
    if (!pocketId) {
      return c.json({ 
        success: false, 
        error: 'Missing pocketId' 
      }, 400);
    }
    
    const result = await unarchivePocket(pocketId, monthKey);
    
    return c.json({
      success: true,
      data: result
    });
  } catch (error) {
    console.log(`Error unarchiving pocket: ${error}`);
    return c.json({ 
      success: false, 
      error: error.message 
    }, 400);
  }
});

// Get archived pockets
app.get("/make-server-3adbeaf1/archived", async (c) => {
  try {
    const archived = await getArchivedPockets();
    
    return c.json({
      success: true,
      data: {
        archived,
        count: archived.length
      }
    });
  } catch (error) {
    console.log(`Error fetching archived pockets: ${error}`);
    return c.json({ success: false, error: error.message }, 500);
  }
});

// Get archive history
app.get("/make-server-3adbeaf1/archive/history", async (c) => {
  try {
    const history = await getArchiveHistory();
    
    return c.json({
      success: true,
      data: {
        history,
        count: history.length
      }
    });
  } catch (error) {
    console.log(`Error fetching archive history: ${error}`);
    return c.json({ success: false, error: error.message }, 500);
  }
});

// ============================================
// POCKETS ENDPOINTS (Additional endpoints - main GET endpoint is above)
// ============================================

// Create custom pocket
app.post("/make-server-3adbeaf1/pockets/:year/:month", async (c) => {
  try {
    const year = c.req.param("year");
    const month = c.req.param("month");
    const monthKey = `${year}-${month}`;
    const body = await c.req.json();
    const { name, description, icon, color, enableWishlist } = body;
    
    if (!name || !name.trim()) {
      return c.json({ 
        success: false, 
        error: 'Pocket name is required' 
      }, 400);
    }
    
    // Get current pockets
    const pockets = await getPockets(monthKey);
    
    // Check if name already exists
    if (pockets.some((p: Pocket) => p.name.toLowerCase() === name.trim().toLowerCase())) {
      return c.json({ 
        success: false, 
        error: 'Pocket with this name already exists' 
      }, 400);
    }
    
    // Create new pocket
    const newPocket: Pocket = {
      id: `pocket_${Date.now()}_${crypto.randomUUID().substring(0, 8)}`,
      name: name.trim(),
      type: 'custom',
      description: description?.trim(),
      icon: icon || 'Wallet',
      color: color || 'blue',
      order: pockets.length + 1,
      createdAt: new Date().toISOString(),
      enableWishlist: enableWishlist !== undefined ? Boolean(enableWishlist) : true  // Default to true for custom pockets
    };
    
    // Add to pockets list
    pockets.push(newPocket);
    await kv.set(`pockets:${monthKey}`, pockets);
    
    return c.json({
      success: true,
      data: {
        pocket: newPocket,
        message: `Kantong "${name}" berhasil dibuat`
      }
    });
  } catch (error) {
    console.log(`Error creating pocket: ${error}`);
    return c.json({ success: false, error: error.message }, 500);
  }
});

// Edit custom pocket
app.put("/make-server-3adbeaf1/pockets/:year/:month/:pocketId", async (c) => {
  try {
    const year = c.req.param("year");
    const month = c.req.param("month");
    const pocketId = c.req.param("pocketId");
    const monthKey = `${year}-${month}`;
    const body = await c.req.json();
    const { name, description, icon, color } = body;
    
    if (!name || !name.trim()) {
      return c.json({ 
        success: false, 
        error: 'Pocket name is required' 
      }, 400);
    }
    
    // Get current pockets
    const pockets = await getPockets(monthKey);
    
    // Find pocket to edit
    const pocketIndex = pockets.findIndex((p: Pocket) => p.id === pocketId);
    if (pocketIndex === -1) {
      return c.json({ 
        success: false, 
        error: 'Pocket not found' 
      }, 404);
    }
    
    const pocket = pockets[pocketIndex];
    
    // Can't edit primary pockets
    if (pocket.type === 'primary') {
      return c.json({ 
        success: false, 
        error: 'Cannot edit primary pockets' 
      }, 400);
    }
    
    // Check if new name already exists (excluding current pocket)
    if (pockets.some((p: Pocket) => 
      p.id !== pocketId && 
      p.name.toLowerCase() === name.trim().toLowerCase()
    )) {
      return c.json({ 
        success: false, 
        error: 'Pocket with this name already exists' 
      }, 400);
    }
    
    // Update pocket
    pockets[pocketIndex] = {
      ...pocket,
      name: name.trim(),
      description: description?.trim(),
      icon: icon || pocket.icon,
      color: color || pocket.color,
    };
    
    await kv.set(`pockets:${monthKey}`, pockets);
    
    return c.json({
      success: true,
      data: {
        pocket: pockets[pocketIndex],
        message: `Kantong "${name}" berhasil diperbarui`
      }
    });
  } catch (error) {
    console.log(`Error editing pocket: ${error}`);
    return c.json({ success: false, error: error.message }, 500);
  }
});

// Delete/unarchive via DELETE method
app.delete("/make-server-3adbeaf1/archive/:pocketId/:year/:month", async (c) => {
  try {
    const year = c.req.param("year");
    const month = c.req.param("month");
    const pocketId = c.req.param("pocketId");
    const monthKey = `${year}-${month}`;
    
    if (!pocketId) {
      return c.json({ 
        success: false, 
        error: 'Missing pocketId' 
      }, 400);
    }
    
    const result = await unarchivePocket(pocketId, monthKey);
    
    return c.json({
      success: true,
      data: result,
      message: result.message
    });
  } catch (error) {
    console.log(`Error unarchiving pocket: ${error}`);
    return c.json({ 
      success: false, 
      error: error.message 
    }, 400);
  }
});

// ============================================
// WISHLIST & SIMULATION - TYPE DEFINITIONS
// ============================================

interface WishlistItem {
  id: string;
  pocketId: string;
  name: string;
  amount: number;
  priority: 1 | 2 | 3;          // 1=High, 2=Medium, 3=Low
  
  // Optional metadata
  description?: string;
  url?: string;                  // Product URL
  imageUrl?: string;             // Product image
  targetDate?: string;           // When planning to buy (ISO date)
  tags?: string[];               // ['gaming', 'electronics']
  
  // Status tracking
  status: 'planned' | 'saving' | 'ready' | 'purchased';
  purchasedAt?: string;          // ISO date
  purchasedExpenseId?: string;   // Link to expense
  
  // Metadata
  createdAt: string;
  updatedAt: string;
  notes?: string;
}

interface SimulationScenario {
  itemId: string;
  itemName: string;
  amount: number;
  currentBalance: number;
  balanceAfter: number;
  status: 'affordable' | 'low-balance' | 'insufficient';
  blockedItems: string[];        // Items that become unaffordable
  warning?: string;
}

interface SimulationResult {
  pocketId: string;
  pocketName: string;
  currentBalance: number;
  
  wishlist: {
    total: number;
    count: number;
    byPriority: {
      high: { count: number; total: number };
      medium: { count: number; total: number };
      low: { count: number; total: number };
    };
  };
  
  // Affordability analysis
  affordableNow: string[];       // Item IDs
  affordableSoon: Array<{        // Need small amount
    itemId: string;
    amountNeeded: number;
    estimatedWeeks: number;
  }>;
  notAffordable: string[];       // Item IDs
  
  // Priority-based scenarios
  scenarios: SimulationScenario[];
  
  // Recommendations
  recommendations: Array<{
    type: 'warning' | 'info' | 'suggestion';
    message: string;
    actionable: boolean;
    action?: {
      type: 'transfer' | 'save' | 'reprioritize';
      params: any;
    };
  }>;
}

interface SavingsPlan {
  itemId: string;
  itemName: string;
  targetAmount: number;
  currentAmount: number;
  amountNeeded: number;
  
  targetDate?: string;
  estimatedDate: string;         // Based on income patterns
  
  // Suggestions
  weeklyTransfer: number;
  monthlyTransfer: number;
  weeksNeeded: number;
}

// ============================================
// WISHLIST ENDPOINTS
// ============================================

// Get wishlist for a pocket
app.get("/make-server-3adbeaf1/wishlist/:year/:month/:pocketId", async (c) => {
  try {
    const year = c.req.param("year");
    const month = c.req.param("month");
    const pocketId = c.req.param("pocketId");
    const monthKey = `${year}-${month}`;
    
    const wishlist = await kv.get<WishlistItem[]>(`wishlist:${monthKey}:${pocketId}`) || [];
    
    // Filter out purchased items by default (unless query param includes them)
    const includePurchased = c.req.query('includePurchased') === 'true';
    const activeItems = includePurchased 
      ? wishlist 
      : wishlist.filter(item => item.status !== 'purchased');
    
    return c.json({
      success: true,
      data: {
        wishlist: activeItems,
        count: activeItems.length,
        total: activeItems.reduce((sum, item) => sum + item.amount, 0)
      }
    });
  } catch (error) {
    console.log(`Error fetching wishlist: ${error}`);
    return c.json({ success: false, error: error.message }, 500);
  }
});

// Add wishlist item
app.post("/make-server-3adbeaf1/wishlist/:year/:month/:pocketId", async (c) => {
  try {
    const year = c.req.param("year");
    const month = c.req.param("month");
    const pocketId = c.req.param("pocketId");
    const monthKey = `${year}-${month}`;
    const body = await c.req.json();
    
    const { name, amount, priority, description, url, imageUrl, targetDate, tags, notes } = body;
    
    if (!name || !name.trim()) {
      return c.json({ 
        success: false, 
        error: 'Item name is required' 
      }, 400);
    }
    
    if (!amount || amount <= 0) {
      return c.json({ 
        success: false, 
        error: 'Valid amount is required' 
      }, 400);
    }
    
    // Create new wishlist item
    const newItem: WishlistItem = {
      id: `wishlist_${Date.now()}_${crypto.randomUUID().substring(0, 8)}`,
      pocketId,
      name: name.trim(),
      amount: parseFloat(amount),
      priority: priority || 2, // Default to medium
      description: description?.trim(),
      url,
      imageUrl,
      targetDate,
      tags: tags || [],
      status: 'planned',
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      notes
    };
    
    // Get existing wishlist
    const wishlist = await kv.get<WishlistItem[]>(`wishlist:${monthKey}:${pocketId}`) || [];
    wishlist.push(newItem);
    await kv.set(`wishlist:${monthKey}:${pocketId}`, wishlist);
    
    return c.json({
      success: true,
      data: {
        item: newItem,
        message: `"${name}" ditambahkan ke wishlist`
      }
    });
  } catch (error) {
    console.log(`Error adding wishlist item: ${error}`);
    return c.json({ success: false, error: error.message }, 500);
  }
});

// Update wishlist item
app.put("/make-server-3adbeaf1/wishlist/:year/:month/:pocketId/:itemId", async (c) => {
  try {
    const year = c.req.param("year");
    const month = c.req.param("month");
    const pocketId = c.req.param("pocketId");
    const itemId = c.req.param("itemId");
    const monthKey = `${year}-${month}`;
    const body = await c.req.json();
    
    const wishlist = await kv.get<WishlistItem[]>(`wishlist:${monthKey}:${pocketId}`) || [];
    const itemIndex = wishlist.findIndex(item => item.id === itemId);
    
    if (itemIndex === -1) {
      return c.json({ 
        success: false, 
        error: 'Wishlist item not found' 
      }, 404);
    }
    
    // Update item
    wishlist[itemIndex] = {
      ...wishlist[itemIndex],
      ...body,
      id: itemId, // Preserve ID
      pocketId, // Preserve pocket ID
      updatedAt: new Date().toISOString()
    };
    
    await kv.set(`wishlist:${monthKey}:${pocketId}`, wishlist);
    
    return c.json({
      success: true,
      data: {
        item: wishlist[itemIndex],
        message: 'Item updated'
      }
    });
  } catch (error) {
    console.log(`Error updating wishlist item: ${error}`);
    return c.json({ success: false, error: error.message }, 500);
  }
});

// Delete wishlist item
app.delete("/make-server-3adbeaf1/wishlist/:year/:month/:pocketId/:itemId", async (c) => {
  try {
    const year = c.req.param("year");
    const month = c.req.param("month");
    const pocketId = c.req.param("pocketId");
    const itemId = c.req.param("itemId");
    const monthKey = `${year}-${month}`;
    
    const wishlist = await kv.get<WishlistItem[]>(`wishlist:${monthKey}:${pocketId}`) || [];
    const filteredWishlist = wishlist.filter(item => item.id !== itemId);
    
    if (wishlist.length === filteredWishlist.length) {
      return c.json({ 
        success: false, 
        error: 'Wishlist item not found' 
      }, 404);
    }
    
    await kv.set(`wishlist:${monthKey}:${pocketId}`, filteredWishlist);
    
    return c.json({
      success: true,
      data: {
        message: 'Item deleted'
      }
    });
  } catch (error) {
    console.log(`Error deleting wishlist item: ${error}`);
    return c.json({ success: false, error: error.message }, 500);
  }
});

// Purchase wishlist item (convert to expense)
app.post("/make-server-3adbeaf1/wishlist/:year/:month/:pocketId/:itemId/purchase", async (c) => {
  try {
    const year = c.req.param("year");
    const month = c.req.param("month");
    const pocketId = c.req.param("pocketId");
    const itemId = c.req.param("itemId");
    const monthKey = `${year}-${month}`;
    const body = await c.req.json();
    const { purchaseDate } = body;
    
    // Get wishlist item
    const wishlist = await kv.get<WishlistItem[]>(`wishlist:${monthKey}:${pocketId}`) || [];
    const itemIndex = wishlist.findIndex(item => item.id === itemId);
    
    if (itemIndex === -1) {
      return c.json({ 
        success: false, 
        error: 'Wishlist item not found' 
      }, 404);
    }
    
    const item = wishlist[itemIndex];
    
    if (item.status === 'purchased') {
      return c.json({ 
        success: false, 
        error: 'Item already purchased' 
      }, 400);
    }
    
    // Create expense
    const expense = {
      id: `expense_${Date.now()}_${crypto.randomUUID().substring(0, 8)}`,
      name: item.name,
      amount: item.amount,
      date: purchaseDate || new Date().toISOString(),
      pocketId: pocketId,
      createdAt: new Date().toISOString(),
      metadata: {
        fromWishlist: true,
        wishlistItemId: item.id,
        wishlistPriority: item.priority
      }
    };
    
    // Save expense
    const expenses = await kv.get<any[]>(`expenses:${monthKey}`) || [];
    expenses.push(expense);
    await kv.set(`expenses:${monthKey}`, expenses);
    
    // Update wishlist item status
    wishlist[itemIndex] = {
      ...item,
      status: 'purchased',
      purchasedAt: expense.date,
      purchasedExpenseId: expense.id,
      updatedAt: new Date().toISOString()
    };
    
    await kv.set(`wishlist:${monthKey}:${pocketId}`, wishlist);
    
    return c.json({
      success: true,
      data: {
        expense,
        updatedItem: wishlist[itemIndex],
        message: `"${item.name}" dibeli dan ditambahkan ke pengeluaran`
      }
    });
  } catch (error) {
    console.log(`Error purchasing wishlist item: ${error}`);
    return c.json({ success: false, error: error.message }, 500);
  }
});

// Simulate wishlist budget
app.post("/make-server-3adbeaf1/wishlist/:year/:month/:pocketId/simulate", async (c) => {
  try {
    const year = c.req.param("year");
    const month = c.req.param("month");
    const pocketId = c.req.param("pocketId");
    const monthKey = `${year}-${month}`;
    
    const simulation = await simulateWishlist(pocketId, monthKey);
    
    return c.json({
      success: true,
      data: simulation
    });
  } catch (error) {
    console.log(`Error simulating wishlist: ${error}`);
    return c.json({ success: false, error: error.message }, 500);
  }
});

// Generate savings plan
app.post("/make-server-3adbeaf1/wishlist/:year/:month/:pocketId/:itemId/savings-plan", async (c) => {
  try {
    const year = c.req.param("year");
    const month = c.req.param("month");
    const pocketId = c.req.param("pocketId");
    const itemId = c.req.param("itemId");
    const monthKey = `${year}-${month}`;
    
    const savingsPlan = await generateSavingsPlan(pocketId, itemId, monthKey);
    
    return c.json({
      success: true,
      data: savingsPlan
    });
  } catch (error) {
    console.log(`Error generating savings plan: ${error}`);
    return c.json({ success: false, error: error.message }, 500);
  }
});

// ============================================
// WISHLIST HELPER FUNCTIONS
// ============================================

/**
 * Generate simulation for pocket wishlist
 */
async function simulateWishlist(
  pocketId: string,
  monthKey: string
): Promise<SimulationResult> {
  // 1. Get current balance
  const balance = await calculatePocketBalance(pocketId, monthKey);
  const currentBalance = balance.availableBalance;
  
  // 2. Get wishlist items
  const wishlist = await kv.get<WishlistItem[]>(`wishlist:${monthKey}:${pocketId}`) || [];
  const activeItems = wishlist.filter(item => item.status !== 'purchased');
  
  // 3. Sort by priority (1=High first)
  const sortedItems = [...activeItems].sort((a, b) => a.priority - b.priority);
  
  // 4. Calculate totals
  const total = activeItems.reduce((sum, item) => sum + item.amount, 0);
  const byPriority = {
    high: {
      count: activeItems.filter(i => i.priority === 1).length,
      total: activeItems.filter(i => i.priority === 1).reduce((sum, i) => sum + i.amount, 0)
    },
    medium: {
      count: activeItems.filter(i => i.priority === 2).length,
      total: activeItems.filter(i => i.priority === 2).reduce((sum, i) => sum + i.amount, 0)
    },
    low: {
      count: activeItems.filter(i => i.priority === 3).length,
      total: activeItems.filter(i => i.priority === 3).reduce((sum, i) => sum + i.amount, 0)
    }
  };
  
  // 5. Simulate cascading purchases
  let runningBalance = currentBalance;
  const scenarios: SimulationScenario[] = [];
  const affordableNow: string[] = [];
  const affordableSoon: Array<any> = [];
  const notAffordable: string[] = [];
  
  for (const item of sortedItems) {
    const balanceAfter = runningBalance - item.amount;
    let status: SimulationScenario['status'];
    
    if (balanceAfter >= item.amount) {
      // Can buy this and still have money for next item
      status = 'affordable';
      affordableNow.push(item.id);
    } else if (balanceAfter >= 0) {
      // Can buy but will be low/zero
      if (balanceAfter < 500000) {
        status = 'low-balance';
      } else {
        status = 'affordable';
      }
      affordableNow.push(item.id);
    } else {
      // Cannot afford
      status = 'insufficient';
      
      const amountNeeded = item.amount - runningBalance;
      if (amountNeeded < 1000000) {
        // Affordable soon
        affordableSoon.push({
          itemId: item.id,
          amountNeeded,
          estimatedWeeks: Math.ceil(amountNeeded / 250000) // Assume Rp 250k/week income
        });
      } else {
        notAffordable.push(item.id);
      }
    }
    
    // Find which items would be blocked if this is purchased
    const blockedItems: string[] = [];
    if (status === 'affordable' || status === 'low-balance') {
      let tempBalance = balanceAfter;
      for (let j = sortedItems.indexOf(item) + 1; j < sortedItems.length; j++) {
        const nextItem = sortedItems[j];
        if (tempBalance < nextItem.amount) {
          blockedItems.push(nextItem.id);
        }
        tempBalance -= nextItem.amount;
      }
    }
    
    scenarios.push({
      itemId: item.id,
      itemName: item.name,
      amount: item.amount,
      currentBalance: runningBalance,
      balanceAfter,
      status,
      blockedItems,
      warning: balanceAfter < 0 
        ? `Kurang Rp ${Math.abs(balanceAfter).toLocaleString('id-ID')}`
        : balanceAfter < 500000
        ? `Sisa hanya Rp ${balanceAfter.toLocaleString('id-ID')}`
        : undefined
    });
    
    // Update running balance for next iteration
    if (status === 'affordable' || status === 'low-balance') {
      runningBalance = balanceAfter;
    }
  }
  
  // 6. Generate recommendations
  const recommendations = generateWishlistRecommendations(
    currentBalance,
    total,
    scenarios,
    affordableNow,
    affordableSoon
  );
  
  // 7. Get pocket info
  const pockets = await getPockets(monthKey);
  const pocket = pockets.find(p => p.id === pocketId);
  
  return {
    pocketId,
    pocketName: pocket?.name || 'Unknown',
    currentBalance,
    wishlist: {
      total,
      count: activeItems.length,
      byPriority
    },
    affordableNow,
    affordableSoon,
    notAffordable,
    scenarios,
    recommendations
  };
}

/**
 * Generate smart recommendations
 */
function generateWishlistRecommendations(
  currentBalance: number,
  wishlistTotal: number,
  scenarios: SimulationScenario[],
  affordableNow: string[],
  affordableSoon: Array<any>
): SimulationResult['recommendations'] {
  const recs: SimulationResult['recommendations'] = [];
  
  // Recommendation 1: Overall affordability
  if (currentBalance >= wishlistTotal) {
    recs.push({
      type: 'info',
      message: `‚úÖ Saldo cukup untuk semua items (Rp ${wishlistTotal.toLocaleString('id-ID')})`,
      actionable: false
    });
  } else {
    const shortage = wishlistTotal - currentBalance;
    recs.push({
      type: 'warning',
      message: `‚ö†ÔøΩÔøΩÔøΩ Kurang Rp ${shortage.toLocaleString('id-ID')} untuk beli semua items`,
      actionable: true,
      action: {
        type: 'save',
        params: { targetAmount: shortage }
      }
    });
  }
  
  // Recommendation 2: Priority suggestions
  if (affordableNow.length > 0 && affordableNow.length < scenarios.length) {
    recs.push({
      type: 'suggestion',
      message: `üí° Bisa beli ${affordableNow.length} item sekarang (prioritas tertinggi)`,
      actionable: true,
      action: {
        type: 'reprioritize',
        params: { affordableIds: affordableNow }
      }
    });
  }
  
  // Recommendation 3: Savings plan for "soon" items
  if (affordableSoon.length > 0) {
    const firstSoon = affordableSoon[0];
    recs.push({
      type: 'suggestion',
      message: `üí∞ Transfer Rp ${Math.ceil(firstSoon.amountNeeded / firstSoon.estimatedWeeks).toLocaleString('id-ID')}/minggu untuk beli dalam ${firstSoon.estimatedWeeks} minggu`,
      actionable: true,
      action: {
        type: 'transfer',
        params: {
          amount: Math.ceil(firstSoon.amountNeeded / firstSoon.estimatedWeeks),
          frequency: 'weekly'
        }
      }
    });
  }
  
  // Recommendation 4: Balance warning
  const firstScenario = scenarios.find(s => s.status === 'low-balance');
  if (firstScenario) {
    recs.push({
      type: 'warning',
      message: `‚ö†Ô∏è Jika beli "${firstScenario.itemName}", sisa hanya Rp ${firstScenario.balanceAfter.toLocaleString('id-ID')}`,
      actionable: false
    });
  }
  
  return recs;
}

/**
 * Generate savings plan for a specific item
 */
async function generateSavingsPlan(
  pocketId: string,
  itemId: string,
  monthKey: string
): Promise<SavingsPlan> {
  const wishlist = await kv.get<WishlistItem[]>(`wishlist:${monthKey}:${pocketId}`) || [];
  const item = wishlist.find(i => i.id === itemId);
  
  if (!item) {
    throw new Error('Wishlist item not found');
  }
  
  const balance = await calculatePocketBalance(pocketId, monthKey);
  const currentAmount = balance.availableBalance;
  const amountNeeded = Math.max(0, item.amount - currentAmount);
  
  // Calculate time needed
  const assumedWeeklyIncome = 250000; // Rp 250k/week
  const weeksNeeded = Math.ceil(amountNeeded / assumedWeeklyIncome);
  
  const targetDate = item.targetDate 
    ? new Date(item.targetDate)
    : new Date(Date.now() + weeksNeeded * 7 * 24 * 60 * 60 * 1000);
  
  const estimatedDate = new Date(Date.now() + weeksNeeded * 7 * 24 * 60 * 60 * 1000);
  
  return {
    itemId: item.id,
    itemName: item.name,
    targetAmount: item.amount,
    currentAmount,
    amountNeeded,
    targetDate: item.targetDate,
    estimatedDate: estimatedDate.toISOString(),
    weeklyTransfer: Math.ceil(amountNeeded / weeksNeeded),
    monthlyTransfer: Math.ceil(amountNeeded / (weeksNeeded / 4)),
    weeksNeeded
  };
}

// ============================================
// EXCLUDE STATE ENDPOINTS
// ============================================

// REMOVED: Duplicate exclude-state endpoints (kept at line 1786-1833)

// ============================================
// CATEGORY SETTINGS ENDPOINTS (Phase 8)
// ============================================

/**
 * Get category settings for current user
 * GET /make-server-3adbeaf1/categories/settings
 */
app.get("/make-server-3adbeaf1/categories/settings", async (c) => {
  try {
    // For now, we're using a single user. In production, extract from auth token
    const userId = "default_user";
    const key = `category_settings_${userId}`;
    
    const settings = await kv.get(key);
    
    if (!settings) {
      return c.json({ error: "Settings not found" }, 404);
    }
    
    return c.json({ settings });
  } catch (error: any) {
    console.error("Error fetching category settings:", error);
    return c.json({ error: `Failed to fetch category settings: ${error.message}` }, 500);
  }
});

/**
 * Save category settings for current user
 * POST /make-server-3adbeaf1/categories/settings
 */
app.post("/make-server-3adbeaf1/categories/settings", async (c) => {
  try {
    const body = await c.req.json();
    const { settings } = body;
    
    if (!settings) {
      return c.json({ error: "Settings object is required" }, 400);
    }
    
    // Validate settings structure
    if (!settings.version || typeof settings.version !== 'number') {
      return c.json({ error: "Invalid settings: version is required" }, 400);
    }
    
    // For now, we're using a single user. In production, extract from auth token
    const userId = "default_user";
    const key = `category_settings_${userId}`;
    
    // Save settings
    await kv.set(key, settings);
    
    return c.json({ success: true, settings });
  } catch (error: any) {
    console.error("Error saving category settings:", error);
    return c.json({ error: `Failed to save category settings: ${error.message}` }, 500);
  }
});

/**
 * Get category spending tracking for current month
 * GET /make-server-3adbeaf1/categories/tracking/:monthKey
 */
app.get("/make-server-3adbeaf1/categories/tracking/:monthKey", async (c) => {
  try {
    const monthKey = c.req.param("monthKey");
    const userId = "default_user";
    const key = `category_tracking_${userId}_${monthKey}`;
    
    const tracking = await kv.get(key);
    
    if (!tracking) {
      return c.json({ month: monthKey, tracking: {} });
    }
    
    return c.json(tracking);
  } catch (error: any) {
    console.error("Error fetching category tracking:", error);
    return c.json({ error: `Failed to fetch category tracking: ${error.message}` }, 500);
  }
});

/**
 * Update category spending tracking (called after expense add/edit/delete)
 * POST /make-server-3adbeaf1/categories/tracking/:monthKey
 */
app.post("/make-server-3adbeaf1/categories/tracking/:monthKey", async (c) => {
  try {
    const monthKey = c.req.param("monthKey");
    const body = await c.req.json();
    const { tracking } = body;
    
    if (!tracking) {
      return c.json({ error: "Tracking object is required" }, 400);
    }
    
    const userId = "default_user";
    const key = `category_tracking_${userId}_${monthKey}`;
    
    await kv.set(key, { month: monthKey, tracking });
    
    return c.json({ success: true, month: monthKey, tracking });
  } catch (error: any) {
    console.error("Error updating category tracking:", error);
    return c.json({ error: `Failed to update category tracking: ${error.message}` }, 500);
  }
});

// ============================================
// DATA MIGRATION ENDPOINTS
// ============================================

/**
 * üîß MIGRATION: Fix Income Timestamps
 * 
 * PROBLEM: Old income data has arbitrary UTC timestamps (e.g., 22:47:16.000Z)
 * which convert to wrong dates in WIB timezone.
 * 
 * SOLUTION: Normalize all income timestamps to UTC noon (12:00:00.000Z)
 * to ensure consistent date display across all timezones.
 * 
 * POST /make-server-3adbeaf1/migrations/fix-income-timestamps
 * 
 * Body (optional):
 * {
 *   "dryRun": true,  // If true, only reports what would be fixed without saving
 *   "monthKeys": ["2025-11"]  // Optional: specific months to fix. If empty, fixes all.
 * }
 */
app.post("/make-server-3adbeaf1/migrations/fix-income-timestamps", async (c) => {
  try {
    const body = await c.req.json().catch(() => ({}));
    const { dryRun = false, monthKeys = [] } = body;
    
    console.log(`[MIGRATION] Starting income timestamp fix. Dry run: ${dryRun}`);
    
    const results = {
      scanned: 0,
      fixed: 0,
      skipped: 0,
      errors: 0,
      details: [] as any[],
    };
    
    // Helper function to check if timestamp needs fixing
    const needsFix = (dateStr: string): boolean => {
      if (!dateStr || !dateStr.includes('T')) {
        return false;
      }
      
      // Extract time component
      const timePart = dateStr.split('T')[1];
      
      // If it's already UTC noon (12:00:00.000Z), no fix needed
      if (timePart === '12:00:00.000Z') {
        return false;
      }
      
      // Any other time needs fixing
      return true;
    };
    
    // Helper function to fix timestamp
    const fixTimestamp = (dateStr: string): string => {
      // Extract date part (YYYY-MM-DD)
      const datePart = dateStr.split('T')[0];
      
      // Return with UTC noon
      return `${datePart}T12:00:00.000Z`;
    };
    
    // If specific months provided, only scan those
    // Otherwise, scan all income entries
    let incomesToScan: any[] = [];
    
    if (monthKeys.length > 0) {
      // Scan specific months
      for (const monthKey of monthKeys) {
        const prefix = `income:${monthKey}:`;
        const monthIncomes = await kv.getByPrefix(prefix);
        incomesToScan.push(...(monthIncomes || []));
      }
    } else {
      // Scan all incomes (get all keys starting with "income:")
      const allIncomes = await kv.getByPrefix('income:');
      incomesToScan = allIncomes || [];
    }
    
    console.log(`[MIGRATION] Found ${incomesToScan.length} income entries to scan`);
    
    // Process each income
    for (const income of incomesToScan) {
      results.scanned++;
      
      try {
        const { id, date } = income;
        
        if (!date) {
          results.skipped++;
          results.details.push({
            id,
            status: 'skipped',
            reason: 'No date field',
          });
          continue;
        }
        
        if (!needsFix(date)) {
          results.skipped++;
          results.details.push({
            id,
            status: 'skipped',
            reason: 'Already normalized',
            date,
          });
          continue;
        }
        
        // Extract month key from income id or date
        const oldDate = date;
        const newDate = fixTimestamp(date);
        
        // Extract year-month from the income key
        // Key format: income:YYYY-MM:uuid
        // We need to reconstruct the key from the income data
        const monthMatch = oldDate.match(/^(\d{4}-\d{2})/);
        if (!monthMatch) {
          results.errors++;
          results.details.push({
            id,
            status: 'error',
            reason: 'Cannot extract month from date',
            date: oldDate,
          });
          continue;
        }
        
        const monthKey = monthMatch[1];
        const key = `income:${monthKey}:${id}`;
        
        if (!dryRun) {
          // Update the income with fixed timestamp
          const updatedIncome = {
            ...income,
            date: newDate,
            updatedAt: new Date().toISOString(),
            _migratedAt: new Date().toISOString(), // Mark as migrated
          };
          
          await kv.set(key, updatedIncome);
        }
        
        results.fixed++;
        results.details.push({
          id,
          status: 'fixed',
          oldDate,
          newDate,
          key,
        });
        
      } catch (error: any) {
        results.errors++;
        results.details.push({
          id: income.id,
          status: 'error',
          reason: error.message,
        });
        console.error(`[MIGRATION] Error processing income ${income.id}:`, error);
      }
    }
    
    console.log(`[MIGRATION] Complete. Scanned: ${results.scanned}, Fixed: ${results.fixed}, Skipped: ${results.skipped}, Errors: ${results.errors}`);
    
    return c.json({
      success: true,
      dryRun,
      summary: {
        scanned: results.scanned,
        fixed: results.fixed,
        skipped: results.skipped,
        errors: results.errors,
      },
      details: results.details,
      message: dryRun 
        ? `DRY RUN: Would fix ${results.fixed} income entries` 
        : `Successfully fixed ${results.fixed} income entries`,
    });
    
  } catch (error: any) {
    console.error("[MIGRATION] Fatal error:", error);
    return c.json({ 
      success: false, 
      error: `Migration failed: ${error.message}` 
    }, 500);
  }
});

// üîß MIGRATION ENDPOINT: Fix expenses with wrong month keys
// Example: expense:2025-11:xxx with date 2025-10-25 ‚Üí move to expense:2025-10:xxx
app.post("/make-server-3adbeaf1/migrate-expense-keys", async (c) => {
  try {
    const body = await c.req.json();
    const { year, month, dryRun = true } = body;
    
    console.log(`[EXPENSE KEY MIGRATION] Starting for ${year}-${month} (dryRun: ${dryRun})`);
    
    if (!year || !month) {
      return c.json({ 
        success: false, 
        error: "year and month are required" 
      }, 400);
    }
    
    const prefix = `expense:${year}-${month}:`;
    const expenses = await kv.getByPrefix(prefix);
    
    console.log(`[EXPENSE KEY MIGRATION] Found ${expenses.length} expenses with prefix ${prefix}`);
    
    const results = {
      scanned: 0,
      needsMigration: 0,
      migrated: 0,
      skipped: 0,
      errors: 0,
      details: [] as Array<{
        id: string;
        status: string;
        oldKey?: string;
        newKey?: string;
        oldMonth?: string;
        actualMonth?: string;
        reason?: string;
      }>
    };
    
    for (const expense of expenses) {
      results.scanned++;
      
      try {
        const { id, date } = expense;
        
        if (!date || !id) {
          results.skipped++;
          results.details.push({
            id: expense.id || 'unknown',
            status: 'skipped',
            reason: 'Missing date or id'
          });
          continue;
        }
        
        // Extract actual month from date field
        const actualDate = new Date(date);
        const actualYear = actualDate.getUTCFullYear();
        const actualMonth = String(actualDate.getUTCMonth() + 1).padStart(2, '0');
        const actualMonthKey = `${actualYear}-${actualMonth}`;
        const urlMonthKey = `${year}-${month}`;
        
        // Check if migration needed
        if (actualMonthKey === urlMonthKey) {
          results.skipped++;
          results.details.push({
            id,
            status: 'correct',
            actualMonth: actualMonthKey
          });
          continue;
        }
        
        // Needs migration!
        results.needsMigration++;
        
        const oldKey = `expense:${urlMonthKey}:${id}`;
        const newKey = `expense:${actualMonthKey}:${id}`;
        
        console.log(`[EXPENSE KEY MIGRATION] ${id}: ${oldKey} ‚Üí ${newKey}`);
        
        if (!dryRun) {
          // Delete old key
          await kv.del(oldKey);
          
          // Save to correct key
          await kv.set(newKey, expense);
          
          results.migrated++;
          results.details.push({
            id,
            status: 'migrated',
            oldKey,
            newKey,
            oldMonth: urlMonthKey,
            actualMonth: actualMonthKey
          });
        } else {
          results.details.push({
            id,
            status: 'would_migrate',
            oldKey,
            newKey,
            oldMonth: urlMonthKey,
            actualMonth: actualMonthKey
          });
        }
        
      } catch (error: any) {
        results.errors++;
        results.details.push({
          id: expense.id || 'unknown',
          status: 'error',
          reason: error.message
        });
        console.error(`[EXPENSE KEY MIGRATION] Error processing ${expense.id}:`, error);
      }
    }
    
    console.log(`[EXPENSE KEY MIGRATION] Complete. Scanned: ${results.scanned}, Needs Migration: ${results.needsMigration}, Migrated: ${results.migrated}, Skipped: ${results.skipped}, Errors: ${results.errors}`);
    
    return c.json({
      success: true,
      dryRun,
      summary: {
        scanned: results.scanned,
        needsMigration: results.needsMigration,
        migrated: results.migrated,
        skipped: results.skipped,
        errors: results.errors
      },
      details: results.details,
      message: dryRun 
        ? `DRY RUN: Found ${results.needsMigration} expenses that need migration` 
        : `Successfully migrated ${results.migrated} expenses`,
    });
    
  } catch (error: any) {
    console.error("[EXPENSE KEY MIGRATION] Fatal error:", error);
    return c.json({ 
      success: false, 
      error: `Migration failed: ${error.message}` 
    }, 500);
  }
});

Deno.serve(app.fetch);